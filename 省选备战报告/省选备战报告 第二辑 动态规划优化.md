---
title: 省选备战报告 第二辑 动态规划优化
updated: 2023-03-26 11:39:56Z
created: 2023-02-28 07:52:22Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

# Part -1 基本术语

首先我们审视一个动态规划的过程，主要有两个部分：

1. 以一定顺序（迭代/搜索/分治）遍历所有状态。
2. 对于每一状态，从一个**有序**集合 $S$ 中挑选出一个元素，利用它计算出本状态的答案。

这个集合叫做决策集合，最终被挑选出来的元素的**下标**叫做最优决策点。

- $x\text D/y\text D$ 动态规划：状态数为 $\Theta(n^x)$，每个状态的决策集合大小为 $\Theta(n^y)$ 的动态规划。

对于一个 $f[a_1,a_2,\cdots] = x$ 而言，$a_k$ 称作“状态”或“维度”，$x$ 称作“DP值”或“信息”。

本文中记号 $f[x]$ 表示一个**待填的数表**；记号 $f(x)$ 表示一个可直接计算的**函数**，但还要进一步化简；记号 $a_x$ 表示一个放置在内存里，可以直接用的序列，无需计算。

# Part 0 四边形不等式及其衍生结论

## § 0.0 1D/1D 四边形不等式

这天，你拿到了一个DP转移方程：

$$
f[i] = \min_{j=1}^{i}\big\{ f[j] + w(j,i) \big\}
$$

你能看出来这是一个 $\text{1D/1D}$ 的动态规划方程，转移他所需要的时间是 $O(n^2)$ 的。

但是这个时候，方程的创造者出现在了你面前，~~毒瘤~~慈悲的他告诉你，他为你创造了一个性质，使得这个方程可以 $O(n\log n)$ 计算完毕。

你恳求他把这个美妙的性质赐予你，但他只告诉你一个古怪的不等式：

$$
l_1<l_2<r_1<r_2 \Leftrightarrow w(l_1,r_1) + w(l_2,r_2) \leq w(l_1,r_2) + w(l_2,r_1)
$$

……并让你自行打表找规律。

打表是不可能打的，先来看看这个性质意味着什么。

由于对于任意一个 $a$， $w(a,a\sim n)$ 在决策集合中加上的数都是一样的（$f[a]$），所以不妨把 $w(a,x)$ 视作一个函数 $F_a(x)$ .

然后让我们观察一下两个函数的大小关系。在一段区间 $[L,R]$ 中，两个函数 $F_x,F_y$ 可能有四种关系：

![](DPimg1.png)

> 相交多次的情况，可以拆开变成这四种情况的组合。

不妨令 $x<y$，那么就有 $x<y<L<R$，上面的不等式就可以写成：

$$
F_x(L) + F_y(R) \leq F_x(R) + F_y(L)
$$

也就是黄色圈里面的和小于等于红色圈里面的和：

![](DPimg2.png)

很容易看出来，如果所有的函数都满足这个不等式，那么前三种情况都可能会出现，但第四种是**绝对不可能出现的**。

换句话说，**如果两个函数相交，只能是老函数超过新来的函数，新来的函数不可能超过老函数**。

再来看看这个 DP 的转移。观察对于一个特定的决策位置 $j$ 而言，在 $i$ 不断后移的过程中，它在决策集合里面的权值也可以看做是一个函数：

$$
D_j(i) = f[j] + F_j(i)
$$

加上这个常数之后还能满足刚刚的性质吗？会不会因为函数的平移导致新函数超过老函数？

> 为了规避麻烦，如果讨论连续函数，假设区间取得足够小，函数近似为线性；如果讨论离散函数，取平移后的交点和它前面/后面的一个点讨论。
> 
> 这样就不用考虑非端点位置的函数值带来的影响。

不会的。首先，显然第情况 $3$ 两个函数任意平移也没有影响。那么只需要讨论前两种，而他们本质上是对称的，所以只看第一种。

注意到由于刚刚的不等式的限制，左侧的【黄 $-$ 红】一定小于等于右侧的【红 $-$ 黄】。

![](DPimg3.png)

那么，当我们尝试将下面的函数向上平移的时候，一定是左侧的 $F_y$ 先超过 $F_x$，这样只会变成情况 $4$ . 而继续平移就变成了情况 $2$ .

所以所有的 $D$ 函数满足刚才的性质。换句话说，新函数会钻到老函数的下面，而反过来不会。

考虑到每次转移中所做的事情就是：在所有 $D$ 中，挑出最下面的那个函数赋给 $f[i]$ .

所以如果 $D$ 最下面的函数只会在自变量增大的过程中被更晚一些出现的函数所取代，那么决策点自然是单调向右移动的了。

由此得出结论：如果满足“正向的”四边形不等式，并且转移方程取的是 $\min$，就具有决策单调性。当然，“反向的”四边形不等式和 $\max$ 也有类似的性质。

## § 0.1 二分栈与二分队列

如何利用这个性质？

首先，假设每个位置的最优决策点都是 $0$ .

从左往右考虑每一个位置 $i$，在只考虑 $[0,i]$ 内的所有决策点时，以 $i$ 为最优决策点的所有位置一定构成一个后缀（因为一旦 $i$ 成为了最优决策点，没有人能够把他淘汰掉）。

依次二分出这个后缀从哪里开始即可。

> 注意，普通的决策单调性是不支持在这里二分的，只有满足四边形不等式才可以二分。因为我们要保证在一个分界点之前 $i-1$ 比 $i$ 优，在这个点之后 $i$ 比 $i-1$ 优。

当然这个方法也可以稍加改动，维护一个单调队列，一个元素形如 $(l,r,k)$，表示 $[l,r]$ 这个区间的最优决策点是 $k$ . 每次检查队头要不要弹出，然后用刚刚二分的方法把 $i$ 作为决策点插入进去即可。

> 具体的方法就是每次检查 $l$ 处的优劣情况，如果 $i$ 更优就 `pop` 掉最后面的元素。找到第一个不优的就在这个区间里面二分。

这个队列就叫做**二分队列**。

据此我们可以引出**二分栈**的概念。

假设我们满足“正向的”四边形不等式，但是转移方程取的是 $\max$，应该如何优化？

虽然现在没有决策单调性，但是可以满足新来的决策点一定是被以前的老决策点取代掉。

> ~~老选手逆袭了！~~

这意味着如果一个决策点刚进来的时候不是最优，后边就不用管他了。

我们可以维护一个单调栈，每个元素依然形如 $(l,r,k)$，一个决策点进来的时候先和目前的栈顶（如果存在的话）二分，然后插入栈中。

至于当前的最优决策点，直接取栈顶即可。

## § 0.2 限制区间分拆个数

假设我们限定区间分拆的数量，该如何做？

$$
f[i,j] = \min_{k=0}^{i-1}\{f[k,j-1] + w(k+1,i)\}
$$

其实很简单，每一层做一遍刚刚的二分队列就可以了，时间复杂度是 $O(nm\log n)$ .

这个模型还有一个至关重要的性质，$f[n,m]$ 关于 $m$ 是下凸的。

记 $f(x) = f[n,x]$ 考虑证明 $f(x-1) + f(x+1) \geq 2f(x)$ .

考虑 $f(x-1)$ 和 $f(x+1)$ 对应的方案，相当于在序列上放了 $x-2,x$ 个分割点。

根据鸽巢原理，$f(x-1)$ 的方案里面必定会有至少一段包含了 $f(x+1)$ 方案中的一段。

考虑做如下变换：

![](DPimg4.png)

上方的两个分别是 $f(x-1)$ 和 $f(x+1)$ 的方案，下方两个的蓝色部分由上方的两个交换得到。

记下方两种划分方案得权值为 $C,D$ .

观察到橙色和红色部分恰好满足四边形不等式，蓝色部分相等，因此 $f(x-1) + f(x+1)\geq C+D$ .

同时注意到，$C,D$ 两种方案都分了 $k$ 段，那么就有不等式：

$$
2f(k) \leq C+D \leq f(x-1) + f(x+1)
$$

> 为什么 $CD$ 都有 $k$ 段？
> 
> 可以考虑左侧的深蓝、浅蓝两个部分，一定有一种分割方法使得浅蓝色中段的数量比深蓝色少恰好一个。证明可以利用抽屉原理，如果按照某一个“包含”的位置分割：
> - 若浅蓝色中段数量小于深蓝色减一，在右边继续找。
> - 若浅蓝色中段数量大于深蓝色减一，在左边继续找。

## § 0.3 二维决策单调性

我们考虑区间动态规划，它的一般形式是这样的：

$$
f[L,R] = \min_{k=L}^{R}\big\{ f[L,k] + f[k+1,R] \big\} + w(L,R)
$$

> 显然这是一个 2D/1D 动态规划。
