---
title: 省选备战报告 第零辑 块与根号平衡
updated: 2023-03-29 09:25:42Z
created: 2023-02-26 09:48:47Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

**本笔记仅仅记录重点思路，详细解题过程请参阅原题题解**

难度从低到高为

- NÄIVE：有效思考时间少于十分钟
- EASY：能够完全独立得出
- MEDIUM EASY：需要题解提供关键思路跨越
- MEDIUM：需要查看题解的较多思路
- HARD：必须查看题解、并用长时间理解
- HELL：花费极长时间理解，非常难以复现（在yx的博客里此难度标记为medium）

带有加号表示实现细节较多、需要格外注意。

带有星号表示这是强思维弱代码。

~~完全不会做的题目不包括在难度列表中~~

# Part 0 根号平衡

根号平衡的基本思路是在两种暴力算法之间取得平衡，一般来说是【暴力预处理】和【直接处理询问】。

把询问按照大小，以 $B$ 为界限分为两类，这两种暴力方法中，【预处理】受到“值域”/“答案个数”/“数据量”等（即**块的大小**）的限制，在大小 $\leq B$ 的情况下占优势，时间复杂度为 $O(nB)$；
而【暴力处理询问】的时间有可能会受到“出现次数”/“答案大小”（即**块的个数**）的限制，在块大的时候展现优势，时间复杂度为 $O(\frac{n}{B}\times n)$ . 这样我们可以取 $B = \sqrt{n}$ ，平衡两种复杂度，做到整体 $O(n\sqrt{n})$ .

## 题目整理

### T0.0 [[SD&SXOI2022] Day1T1 整数序列](https://www.luogu.com.cn/problem/P8349)

**Tag**

根号分治、复杂度分析、暴力

带 $\sqrt{\log}$ 做法：**MEDIUM**（思维中等；细节多；代码中等）

严格根号做法：**MEDIUM+**（思维中等；细节极多；代码长）

**为何想到根号分治**

每次提问中相互影响的仅有两种数据，且若规模相差悬殊，时间只取决于较小的那一个。

根号分治的特点在于，按照数量将原始数据分类。其中小块受到大小限制，大块受到个数限制。思维的关键点在于小对大的处理。

处理时利用小块数量少的特点，将此特点转化为搜索空间小的优势。

**时间复杂度分析**

由于大对小时间复杂度取决于小块的长度，那就尽量把最长的小块多问几次。所以当假设有 $K$ 个大块， $k$ 个小块时，先用最长的小块挨个问一遍大块，再用次大的、次次大的……以此类推。合起来，就是用最大的 $\frac{q}{K}$ 个小块向每个大块各问一遍。而最强的情况下就是没有落下的小块，$k=\frac{q}{K}$ . 

接下来更进一步，每处理一个询问所需要的时间是【扫描所有 $O(\text{小块长度})$ 个点 $\times$ 在 `set` 中查找】，总复杂度为：

$$
\sum_{i=1}^{k}\sum_{j=1}^{K}l_i\log L_i
$$

> $l_i$ 表示小块长度， $L_i$ 表示大块长度

放缩，上式一定小于

$$
\sum_{i=1}^{k}\sum_{j=1}^{K}l_i\log n
$$

化简后可得

$$
Kn\log n
$$

也就是

$$
O\left(\frac{n^2\log n}{B}\right)
$$

**不严格根号做法**

小对小直接暴力，大对大也直接暴力，考虑到大块数量少，后者可以记忆化，这两部分耗时 $O(qB + \frac{n^2}{B})$ . 小对大的情况下筛选出有效点（对于小块的每个点，分别向前向后找到一个还没有被这一过程选过的大点），然后用有效点暴力，时间复杂度上面分析过了。

因此总复杂度为 $O(qB+\frac{n^2\log n}{B})$ ，由均值不等式可得 $B$ 应取 $\sqrt{\frac{n^2\log n}{q}}$ . 总复杂度为 $O(n\sqrt{q}\cdot\sqrt{\log n})$ ，由于最后的 $\sqrt{\log n}$ 很小，所以把 $B$ 稍稍取小一点就足够通过本题。

**严格根号做法**

上一种做法中，为了筛出所有的有效点，需要采用 `set` 维护有效点的区间，考虑如何移除掉`set` 。

首先是刚刚的转化：对于每个连续段，【向前、前后找一段和他长度相同的，最后去重】相当于【对于里面的每一个点，向前向后分别找一个，最后去重】。

因为我们需要寻找一个 $x$ 点前后的第一个 $y$ 点，考虑用栈完成。栈中存储在【 $y$ 构成的纯净区间】上画出的所有的有效区间，每次查询新位置 $x_i$ 前后的第一个  $y$ 的位置，找到这两个位置在纯净区间中对应的位置。我们知道这两个位置一定是紧挨着的，把他们视做一个区间，塞进栈里，然后试图与次栈顶合并。

具体如何合并呢？找到【栈顶、次栈顶】两个区间相交的长度，然后把**两区间的并**向前、向后分别延长这个长度。然后把栈顶弹出，把合并后的新区间塞进去。完毕后，再尝试把新栈顶和次栈顶合并，直到无法合并为止。

- 举例：$[12,19] + [14,15] \Rightarrow [10,21]$
- 又如：$[7,10] + [9,11]\Rightarrow [5,13]$

当然这样有效点的总数就不再是 $2\times \text{cnt}(x)$ 了，而是比他略大一些，不过有效点的数量仍然是 $O(n)$ 级别的。

**要有耐心**

一句话，代码共有 `4.7KiB` 。

### T0.1 [[ZJOI2022] Day1T2 众数](https://www.luogu.com.cn/problem/P8349)

**Tag**

根号平衡、复杂度分析

难度：**HARD**（思维较难；细节多；代码中等）

**为何判定为根号分治**

一般有有关于“众数”、“出现次数”的题目都应想到根号分治，因为这种题目需要处理颜色个数类的信息。

**如何转化问题**

“加上任意数”这种条件可以直接忽略，因为这种操作可以把任意数转化为任意数。问题的本质是把区间分成两段，并在内外各选出一个数，使得这两个数的出现次数总和是所有情况中最大的。

进一步，我们发现对答案产生贡献的仅有这两个数，并且它们也一定分别是内区间与外区间的众数（若不是的话，取众数更优）。这样问题表现出了显著的根号平衡特征。

> 经验：根号分治适用于“两两相对”/“需要考虑出现次数”类的问题

**“小对大”、“大对大”时间复杂度分析**

在处理大对小、大对大的情况时，我们需要枚举大块 $x$ 并在内层枚举所有块 $y$ 并对内层块构成的纯净区间求前缀和。

> 纯净区间，即把颜色为 $y$ 的所有点单独拉出来组成的区间。

由于在枚举每一个大颜色的时候，还会对除它外的所有颜色（无论大小）计算一遍前缀和，因为所有颜色的纯净区间长度总和为 $O(n)$，总时间复杂度是 $O(n\sqrt{n})$ .

**小对小处理的时间复杂度分析**

小对小的情况下，虽然小块的数量是 $O(n)$ 级别的，但是我们仍有足够的时间枚举每一个【两端均为同种的小颜色】的区间。为什么？因为有下面的式子成立：

> $l_i$ 表示编号为 $i$ 的小颜色所占格子的数量 。

$$
\sum_{i=1}^{num} l_i^2 \leq \sum_{i=1}^{num} l_i\sqrt{n} \leq n\sqrt{n}
$$

此性质可以作为一个熟知结论加以记忆。

考虑我们枚举区间的同时将两侧的点作为外侧选定的颜色，这时需要求出两个点围住的区间（不包括端点）中众数的出现次数

> 为什么钦定为外侧点而非内侧点？因为最终输出答案时要输出外侧众数数值，而不关心内侧的，这样就只需要维护内部区间众数的出现次数了。

如何计算？考虑变换枚举顺序，改为扫描线方法枚举【两端均为同种小颜色】的区间。接下来尝试借助众数关于区间长度的单调性，在每次 $r\leftarrow r+1$ 时 $O(\sqrt{n})$ 更新一个【对于所有 $i$，保存 $[i,r]$ 中众数出现次数】的数组 $S$ .

暴力维护十分简单，每次 $r$ 向右扩展一格时，用 $a[r]$ 这个数的出现次数，按照 $i$ 由大到小的顺序更新 $S[i]$ . 由于区间越长，众数出现次数越多，所以遇到第一个不能被更新的位置时退出循环。

当然单次更新的复杂度是不确定的，考虑总复杂度。发现最终 $S$ 数组的总和不会超过 $n\sqrt{n}$，同时考虑到每次更新至少有一个位置上 $+1$，那么总复杂度为 $O(n\sqrt{n})$，符合时间限制。

> 利用了小块值域小、更新少的特点节省时间

## T0.2 [[CF1039D] You are given a tree](https://www.luogu.com.cn/problem/CF1039D)

**Tag**

贪心及其证明、根号平衡、二分

难度：**MEDIUM EASY**（思维中等；细节少；代码短）

**为什么贪心是对的**

本题的 $[1,\sqrt{n}]$ 部分需要用到朴素的贪心处理 $\sqrt{n}$ 遍，每次解决 “在一棵树上最多能画几条长度为 $k$ 的不相交链” 这样一个问题。

而这个问题可以 $O(n)$ 贪心解决，具体来说，每个点记录“空余链长”，也就是从它开始向下数最长的还未被占用的链长。

对于每一个点，判断它儿子中【空余链长最长、次长的两个】能否放下一条长度为 $k$ 的链。如果能，就把这个点的空余链长记录为 $0$ ；如果不能，空余链长记录为儿子中空余链长最长的再加一。边界条件为【叶节点的空余链长为 $1$ 】。

为什么是对的呢？考虑决策包容性。假设存在一个点 $x$ ，它的两个儿子既可以支持一条通过 $x$ 而不向上延伸的链，但最优解中 $x$ 被一条连向父亲的链通过（没有利用上儿子的孔空余链长），那么我们可以把这条链放下来，充分利用儿子提供给它的空间。

同时，如果只看 $x$ 的上方，最优解中的排布方式还能实现，并且还能获得额外的排布方式；如果只看 $x$ 的下方，排布方式根本没有变化。这样，我们证明了 “把链尽量放下来” 完全包容了最优解。进一步也就证明了贪心的正确性。

**为何考虑到根号平衡**

考虑数值不同的答案的分布情况，发现后半部分出现大量答案重叠，猜测以根号为分界线。

同时注意到答案具有递减的上限，对于第 $k$ 个答案，不会超过 $\frac{n}{k}$ .

具有这种特征时，可以试着考虑根号平衡。

**后半部分的做法**

这一部分有点类似于数论分块。

我们发现最后的 $n-\sqrt{n}$ 个位置分了 $\sqrt{n}$ 个答案数值，那么一定会有重复的。如何确定重复的区域呢？可以使用二分，首先枚举答案 $k$ ，然后对于每个 $k$ 二分查找此时最长的链长度，`check` 函数可以利用刚刚的贪心实现。

> 为什么是二分？因为答案随链长的增加单调不增，具体来说，如果能放下 $t$ 条长度为 $k$ 的链，那么没有理由放不下同样 $t$ 条长度更短的。

把两个部分合起来，时间复杂度为 $O(nB + \frac{n^2\log n}{B})$ 因此可以把块长改为 $\sqrt{n\log n}$ .

**递归转迭代**

如果直接递归，常数仍然过大，我们这时可以尝试把树形 DP 转为迭代实现，具体来说，记录每个点的父亲，按照 DFS 序列倒序 DP，每次把空余链长贡献到父亲。

### T0.3 [[CF786C] Till I Collapse](https://www.luogu.com.cn/problem/CF786C)

**Tag**

根号分治、二分

难度：**NÄIVE**（思维相似；细节少；代码短）

**与上一题类似的判定**

仍然是明确两条性质：

- 答案单调递减，可以二分。
- 第 $k$ 个答案始终不超过 $\frac{n}{k}$ ，因此答案总数不超过 $\sqrt{n}$ ，并且分布前密后疏。

所以做法已经很明确了，前半部分暴力处理，后半部分二分确定重复段，并暴力处理，块长取 $\sqrt{n\log n}$ .

### T0.4 [[CF1508C] Complete the MST](https://www.luogu.com.cn/problem/CF1508C)

**Tag**

根号平衡、带删除、序列维护

难度：**Easy+**（难度中等；细节多；代码短）

**为何是根号分治**

观察到周期为 $k$ 的点在时间轴上产生的贡献差分后约有 $\frac{n}{k}$ 处，也就是说长度 $\geq \sqrt{n}$ 的点贡献较少，可以暴力处理时间轴；长度 $\leq \sqrt{n}$ 的点总数比较少，可以把长度相同的放在一起，暴力取模查询。

**无需离线**

这一道题不需要离线，因为根号分治中用到的都是暴力操作，遇到删除也可以直接暴力处理。大块直接在时间轴上 $-1$ ，小块也可以简单暴力维护

### T0.5 [[POI2015] T7 Odwiedziny](https://www.luogu.com.cn/problem/P3591)

**Tag**

根号平衡、倍增

倍增做法：**NÄIVE**（思维较易；细节少；代码短）
长剖做法：**NÄIVE**（思维较易；细节中等；代码中等）

**如何想到根号平衡**

发现我们有两种方法：求前缀和和暴力跳，前者

## T0.6 [Luogu P7125](https://www.luogu.com.cn/problem/P7125)

**Tag**：根号平衡、众数、MEDIUM

**做法**：枚举中点 $C$，不断增加两侧的长度，考虑这个过程中会发生什么。

显而易见的是，在这个过程中，区间中众数的出现次数单调不减，并且数量不会超过 $cnt(a[C])$，因为一旦超过一定不会合法，可以直接舍去。

那么把这个变化的过程拆为 $O(cnt(a[C]))$ 个子过程，每一个子过程中区间众数的出现次数不变。这样一来，区间合法时的 $r-C+1$ 一定构成这个子过程的一个后缀。

因此，合法区间在 $L-R$ 二维图上一定形成若干条和副对角线平行的线段，一共有 $\sum_{C}cnt(a[C]) = n$ 条。并且两两不重叠。

然后考虑对于一个终点如何求出其对应的若干个半径长度区间（刚刚提到的“子过程”）。考虑根号分治。

对于 $cnt(a[C])\leq \sqrt{n}$ 的，对每个 $k\in[1,\sqrt{n}+1]$ 预处理出来 $p_{k,x}$ 表示从 $x$ 开始，区间**至少**需要有多长才能让众数出现次数为 $k$ .

枚举 $C$，对于每一个 $k\in[1,cnt(a[C])]$ 二分出来一个最大的 $x$，满足 $2i-x\in[p_{k,x},p_{k+1,x})$，这样 $[x,2i-x]$ 就是以 $C$ 为中点，并且众数出现 $k$ 次的区间了。

对于 $cnt(a[C])\geq sqrt{n}$ 的，他们最多只有 $\sqrt{n}$ 个，所以每一个暴力扫描一遍整个序列就行了。

求出所有的子过程，结合 $a[C]$ 出现的位置，可以求出子过程中“合法后缀”的位置，这样预处理工作就完成了。

剩下的部分是一个斜线加，矩形查，很简单就不赘述了。矩形按照副对角线劈开，左右两侧分别在两个掰过的坐标系上处理即可。

# Part 1 分块

分块相当于一种不需要合并子节点信息的线段树。假如我们不能快速合并两个区间的信息，或者标记永久化不方便，那么我们可以使用分块来规避合并操作。

一个经典的例子是区间加线段、区间查最大值。一般使用分块维护凸包。

另外一种常见的思路是对于操作&询问序列进行分块处理，而非对于被询问的结构。每个块内用 $O(q)$ 或者 $O(n)$ 或者 $O(B^2)$ 的时间解决问题即可（前两种复杂度处理“块外”操作带来的影响，后面的解决“块内”带来的影响，即暴力枚举块内的每一个修改操作，用 $O(1)$ 的时间计算它对当前询问的影响）。

**分块维护区间“数对”的贡献**

可以考虑维护以下的东西：

- `WtoL[B][N]`，维护第 $B$ 个块中的点与 $N$ 号点形成的贡献之和。
- `SWtoL[][]`，上面那一个数组在 $N$ 这一维的前缀和。
- `WtoW[B1][B2]`，维护 $B_1$ 块与 $B_2$ 块这两块中的点产生的贡献，要求点对的一个属于 $B_1$，另一个属于 $B_2$ . 可以通过 `SWtoL` 求出。
- `SWtoW[L][R]`，$L,R$ 这个“整块区间”中任意点对的贡献之和。


### T1.0.0 [Luogu P5443](https://www.luogu.com.cn/problem/P5443)

**Tag**：操作分块、图上询问、MEDIUM EASY

**做法**：操作序列分块，每个块内尽量用 $O(q)$ 级别的算法解决。

首先把所有边排序，块内被更改的 $O(B)$ 条边先拿出来。

由小到大向可撤销并查集中加入所有边，回答一个询问的时候把更改的 $O(B)$ 条边中权值小于等于它的也扔到并查集里面。解答完询问后统统撤销掉。

复杂度 $O(\frac{q}{B}(B^2+m)\log n)$ .（提前给每个块内排好序，每次归并起来，因此排序部分复杂度 $O(m)$）

不过还可以优化。

每次解答询问的时候建一个图，其中的每个点有点权，表示并查集中以他为根的连通块大小，然后把修改涉及的 $O(B)$ 条边丢进去。

由于每次只会搜到 $O(B)$ 个点，所以直接dfs时间复杂度有保证。

复杂度 $O(\frac{q}{B}(B^2+m\alpha))$，即 $O(q\sqrt{m\alpha})$ .

### T1.0.1 [CF 1588F](https://www.luogu.com.cn/problem/CF1588F)

**Tag**：操作分块、图上询问、多重结构、MEDIUM+

**做法**：首先操作分块。

### T1.0.2 [Luogu P8261](https://www.luogu.com.cn/problem/P8261)

**Tag**：根号平衡、分块、计算几何、随机保证性质、MEDIUM

**解法1**：

考虑半平面数点问题的标准解法：先分块，然后每个块内扫描线扫分界线的斜率，按照目前的斜率将所有点投影到 $y$ 轴上，然后变成一维数点问题。同时要注意扫描线的过程中可能会有两个点的相对位置发生交换，所以需要提前把 $O(B^2)$ 个发生交换的时间和对象处理出来，扫描的同时用堆维护即可。

复杂度为 $O(\frac{n}{B}(q\log B+B^2\log B))$，取 $B=\sqrt{q}$，时间复杂度为 $O(n\sqrt{q}\log q)$ .

这个问题可以用类似的方法解决，考虑分块外面套一层根号分治。把出现次数大于等于 $B$ 的颜色拿出来，每个单独做一遍。所有颜色中分出块的总个数是 $O(\frac{n}{B}$ 级别的，不会超时。

然后是出现次数 $<B$ 的颜色，可以把他们打包成若干个大小为 $B\sim 2B$ 的块，保证一个颜色只在一个块中出现。然后扫描线的时候树状数组维护每个前缀中有多少个二元组，注意到一次交换一定是相邻的两个元素，并且影响一个后缀。

**解法2**：

## 树分块

一般的方法是dfs的时候记录一下这个点子树的大小，如果 `siz[u]>B` 就标记 $u$ 点为界点，同时令 `siz[u] = 0` . 或者直接随机泼洒 $\frac{n}{B}$ 个点。

普通的分块这一步就结束了，但是还有更高级的分法。

把所有界点的虚树求出来，这一步可以再来一次dfs解决。dfs的过程中标记每个点的根链，一个点被重复标记就设置成界点，最后把根设成界点。

这样分出来的每一个块最多有两条出边，称为一个簇。因而穿过这个簇的路径的簇内部分进有一种可能，这条路径称为这个簇的路径。

### T1.1.0 [Luogu P9136](https://www.luogu.com.cn/problem/P9136)

**Tag**：树分块、定期重构、MEDIUM

**做法**：先考虑只有 $3,4$ 操作怎么做。使用树分块，每个簇维护其路径上所有点的权值构成的有序数组，查询的时候每个整块二分。

加的时候散块非路径部分暴力加，路径部分把要加的点挑出来加上，再归并回去。整块挨个打标记。

加上 $1,2$ 操作怎么办？考虑 $1,2$ 操作实际上对树的形态影响有限，可以直接暴力修改树的形态而不影响分块的结构。

但是如果累积了太多修改，可能会使得某些块过大，分块失去平衡，所以要适时重构整个树分块结构。

设块的数量为 $A$，每 $T$ 次操作进行一次重构，则四种操作的复杂度为：

1. $O(\frac{n}{A}+T)$ .
2. $O(1)$ .
3. $O(A+\frac{n}{A}+T)$ .
4. $O(A\log n+\frac{n}{A}+T)$ .

重构的总复杂度为 $O(\frac{m}{T}n\log n)$ .

取 $A=\sqrt{\frac{n}{\log n}},T=\sqrt{n\log n}$，总复杂度为 $O(m\sqrt{n\log n})$ .

## 小分块

小分块指长度为 $\log n$ 的分块.又被称为“四毛子”技巧。

具体来说就是用 $O(2^B)$ 个二进制数表示每一块内的所有可能出现的状态，

### T1.2.0 [Luogu P8985](https://www.luogu.com.cn/problem/P8985)

**Tag**：小分块、邻项交换、逐块处理、MEDIUM

**做法**：首先可以注意到非常经典的Exchange Argument模型。如果用普通的四维偏序，很难把“把满足偏序的东西拿出来排序”这一步做到很优。

四毛子有一个用法，可以把 $k$ 维偏序做到 $O(\frac{kn^2}{\log n})$ .

所以转变思路，先给所有怪物排好序，然后相当于全局询问满足四维偏序的子序列中，第一个前缀和为 $0$ 的位置。

考虑分块，最直接的想法是用 `bitset` 处理出每个维度上某个前缀对应的集合，高维偏序相当于集合求交。

但是接下来要用 $O(B)$ 的复杂度计算这些元素的和，显著拖慢了我们的速度，因为如果每个块中的复杂度带有系数 $B$ 的话，总体的复杂度就会退化为 $O(nq)$ .

因此考虑四毛子，预处理处每个块内每个集合的元素和。这样就可以 $O(1)$ 查询了。

总复杂度 $O(\frac{n}{B}(2^B + q))$，当 $B=\log n$ 时取到最小值 $O(\frac{n^2}{\log n})$ .

# Part 2 莫队

