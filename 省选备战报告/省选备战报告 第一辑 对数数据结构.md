# Part -1 常用概念

## 维度

一般来说，数据结构题是让你维护一个结构，结构中的每个元素可以被一个 $k$ 元坐标唯一确定。

何为降维？

以计数符合条件的物品数目为例：
你有一些物品，每个物品有n个平行的、具有偏序关系的属性
你有一堆询问，每个询问对物品都的每一个属性都有一个【偏序限制】，即第i维坐标必须小于x_i，那么可以认为询问是n维的

因此询问可以看做【属性偏序限制】的集合

但是如果存在一个维度（属性），满足对于任意一个询问，【仅考虑这个维度时，符合限制的物品数量】都是相等的，那么这个限制就是可以简单去除的。

去除掉那些无论如何都不符合的物品后，这个维度就可以直接扔掉了。

这样，我们就可以无视掉这一个维度。

CDQ分治的本质是把所有物品按照某个维度A排序，再以中点为界限分作两半，分别叫他前/后半部分

对于那些只涉及前半部分的询问，分治下去处理

对于那些前、后都涉及的询问，把它砍作两个询问，一个只和前半部分有关，一个只和后半部分有关

```
......................................（排好序的物品）

---------------------<（询问）
↓
               （中点）
.................|....................（排好序的物品）

----------------<|----<（询问2，只和后半部分有个关）
（询问1，只和前半部分有关）

```

这样，我们发现对于任意一个询问1（记作X），所有的询问对象都符合X这个询问在A这个维度上的限制，也就是说这些询问对象都满足A这一维度上的限制，

那么就可以把A这一维抛弃。

辨析一下两个概念：整数序列、颜色序列。

前者有偏序关系，性质更强，后者没有偏序关系，一般只在意它的异同。

# Part 0 线段树和区间维护

## 矩形周长并

呃，看起来是很基础的东西，但是还是稍微提一下。

在扫描线的时候，相邻两个扫描线停留的位置之间夹的是若干个矩形，不存在中途有边拐弯的情况。

所以我们计算与扫描线平行的外露边的总长时，可以把加边、删边分开，分别计算他们对于周长的影响。

但是注意一定要先加再删，每次做完一堆操作之后，把扫描线上覆盖长度的变化量贡献到答案里面。

为什么？因为如果删去一条边使得扫描线上覆盖长度减少，这些减少的长度可能还会被后面加的边补上，导致多算周长。

但是如果加上一条边使得扫描线上覆盖长度增加，那么以后无论怎么删，都不会把新增的这一部分长度减去。

更进一步的理解是，当扫描线停在 $r$ 这个位置时，先把能加的都加上后，扫描线的覆盖长度代表了 $r$ 这个位置画一条线段，线段上所有“覆盖位置”的总长。而把能减的都减去之后，扫描线上覆盖长度的意义是把上文画的那条线段右移一个微小距离后所有“覆盖位置”的总长。

## 复杂标记合并

线段树的一个标记具体是什么意思？

指的是从“子节点最后一次操作”到现在的这一段时间中所有操作效果的累积。并且受 `tag` 控制的对应信息永远保持在最新状态。

> “子节点最后一次操作”指的是最后一次仅涉及到子节点而不涉及到父节点的操作。

所以当标记与时间有关的时候（如维护历史最大值），需要记住：

假设 `fa` 节点的标记表示了 $[l,r]$ 这段时间里面操作效果的累积，`ls` 节点的 `tag` 保存了 $[p,l]$ 这段时间里面操作的累积。那么现在 `ls` 节点里面受 `tag` 控制的信息为 $l$ 这个时间点上的状态，合并之后这些信息变成最新状态，并且 `ls` 节点的 `tag` 保存的是 $[p,r]$ 这个时间区间里面操作效果的累积。

由于线段树维护的信息具有半群特性，合并 `tag` 的时候把 `fa.tag` 作用在 `ls.tag` 上，再把这个结果和 `ls` 自己原有的 `tag` 合并即可。

> 注意，有的时候用来相互作用的 `ls.tag` 和最后用来合并的 `ls.tag` 不是一个东西。

那合并的时候如何处理 `ls` 节点上受到此 `tag` 控制的信息呢？我们直接让 `fa.tag` 作用在 `ls` 的旧信息（也就是 $l$ 这个时刻的信息）上，然后合并即可。

当然，`rs` 也是同理。

所以当标记复杂时，应当实现一个 `merge` 函数，用以合并标记。同时修改的时候也可以用这个函数以减少码量。

## 吉老师线段树

记住，必须要维护 `tag4`，也就是【非最大值在修改过程中出现的历史最大 `tag` 值】，因为孩子中的最大值可能是父亲的非最大值，需要这个标记来更新自己的历史最大值。

这样，pushdown 的时候，如果某个孩子没有最大值，那么 merge 时，这个孩子的最大值、非最大值所要合并的最大值tag均为 `tag3`，所要合并的**历史**最大值tag均为 `tag4` .

```cpp
void merge(int x,int t1,int t2,int t3,int t4)
{
	fa.sum += 1ll*fa.cnt*t1 + 1ll*(fa.r-fa.l+1-fa.cnt)*t3;
	cmax(fa.tag2,fa.tag1+t2); fa.tag1 += t1;
	cmax(fa.hmx,fa.mx+t2); fa.mx += t1;
	cmax(fa.tag4,fa.tag3+t4); fa.tag3 += t3;
	if(fa.se != -inf) fa.se += t3;
	return;
}

void pushdown(int x)
{
	int tmp = max(ls.mx,rs.mx);
	if(ls.mx == tmp) merge(x<<1,fa.tag1,fa.tag2,fa.tag3,fa.tag4);
	else merge(x<<1,fa.tag3,fa.tag4,fa.tag3,fa.tag4);
	if(rs.mx == tmp) merge(x<<1|1,fa.tag1,fa.tag2,fa.tag3,fa.tag4);
	else merge(x<<1|1,fa.tag3,fa.tag4,fa.tag3,fa.tag4);
	fa.tag1 = fa.tag2 = fa.tag3 = fa.tag4 = 0;
	return;
}
```

如果只需要维护历史信息，那么需要考虑时间线的上的标记合并。而支持区间 `checkmax` 操作相当于把每个区间的值分为了最大值、非最大值两类，对两类分别维护。

### [HNOI2016] 序列

这种对于一个区间的所有子区间求和的题目一般可以使用线段树维护历史版本和+离线来做。

我们维护一个序列 $A_x$ 表示 $\min_{i=x}^{r}a_i$，那么查询一个区间 $[L,R]$ 的所有**后缀**的最小值的和可以表示为扫描线扫到 $R$ 时查询 $\sum_{i=L}^{R} A_i$ .

进一步，我们查询【一个区间 $[L,R]$ 的所有子区间的最小值的和】等于分别查询所有【【形如 $[L,x]$，其中 $x\in[L,R]$】这样的一个区间的所有后缀的最小值的和】，再把他们相加。

> 换句话说就是把子区间分类，使得每一类构成一个后缀集合。

然后我们就可以对 $A$ 序列的 $L\sim R$ 版本分别求一个区间和，再把这些区间和加起来。

为了更快的做到这一点，用一棵线段树维护版本和即可。

然后还需要考虑如何快速移动右端点。

考虑用一个单调栈维护后缀最小值，那么每一个后缀最小值所划分出的连续段内，$A_i$ 的值都是相等的（~~因为 $A_i$ 维护的就是后缀最小值啊~~），所以我们无需进行复杂的区间 `checkmin` 操作，只需要对每一个连续段进行区间加法即可。

由于扫描线的总过程中，单调栈的变化次数是 $O(n)$ 的，时间复杂度是合法的。

## 利用线段树结构二分

有的时候，看起来一个节点需要维护一个序列。但是如果操作只涉及在序列中二分某个位置的话，可以每个节点只维护首尾项，并利用线段树的结构二分。

最典型的例题当然是楼房重建。

### 楼房重建

考虑每个节点维护这个区间内的的前缀最大值组成的序列。

不考虑时间复杂度，如何合并？

二分出后面那个序列中第一个大于前面序列的位置，取这个位置开始的后缀。



## 势能线段树

一般来说，如果每次对于区间的操作会使得之后对于这个区间的“有效操作”数量减少，那么可以往势能方向思考。

> “有效操作”，即需要耗费较长时间进行的操作，“无效操作”即“有效操作”在特殊条件下的退化版本。

另外，有的时候

## 线段树带插入

往一个序列中插入一个数，这种操作如果用线段树维护的话，可以把对应位置留空。

但是如果有区间操作的话，我们无法判断一个位置是空位还是有值的位置。可以用维护点积的技巧，另外开一个权值数组，空位的权值设为 $0$，填了数的位置的权值设为 $1$ .

## 标记永久化

有些时候，标记的作用效果与区间的长度有关，这个时候可以选择标记永久化。

最经典的例子就是区间覆盖，扫描线的板子以及区间加等比数列。

另外李超树也是典型的标记永久化。

## 动态开点

这个东西除了在值域极大的情况下节省空间之外，也可以用来直接把某个区间从一棵树上分裂出来，合并到另一棵树上。也就是支持区间线段树合并。

### CF911G

这个就是上文所讲的区间线段树合并。因为值域很小所以可以开 $100$ 棵动态开点的线段树。

### CF803G

这道题相当nb。考虑动态开点节省空间的前提是一开始的时候整个序列完全未知，但是本题中给出了原始序列，这让我们无法用动态开点暴力维护整个展开后的序列。

但是我们可以把原序列剥离出来，只在树上维护修改带来的信息。考虑原序列在整个修改过程中只会被慢慢覆盖，不会还原。我们没有必要建树的时候带上原序列的信息，因为“没有定义”的节点就代表了原序列的这一段。

使用ST表来维护原序列贡献的最小值，具体来说，如果在大树上合并的时候发现有一个儿子没有定义，那就证明这个儿子里面的最小值是由原序列贡献而来的，利用ST表可以实现 $O(1)$ 查询这个最小值，也就可以 $O(1)$ `Pushup`了。

当然也可以常规做法，我们建立一棵线段树，一个叶节点对应一个块，叶节点的值对应这个块中的最小值。

一开始这棵树所有叶节点都带着同一个值，后来每一次修改中，我们把所有被整体覆盖的块拎出来在这棵树上修改对应叶节点的值，散块在对应的线段树上修改。

当然，散块这部分要开 $K$ 棵动态开点的线段树，用类似可持久化的方法节省空间。

查询同理，在整块树上查一次，散块树上查两次。

# Part 1 树状数组

## 维护高阶前缀和

树状数组仅能支持快速的单点修改、前缀查询操作。

我们希望支持单点修改、单点高阶前缀和查询。

按照 @Alex_Wei 提到的方法，我们应该考虑在一个位置 $x$ 加上 $1$ 之后对于后面的一个位置 $y$ 会产生多少贡献。这个贡献是一个关于 $y$ 的多项式，每一项的系数又是一个关于 $x$ 的多项式。

那么求高阶前缀和相当于找到对于每一项，找到贡献到这一项前面的所有系数并求和。

对于每一项开一个树状数组，下标 $x$ 存储 $x$ 这个点的修改带来的这一项的系数。

查询 $y$ 位置的高阶前缀和的时候，我们相当于对于每一个幂次 $k$，将所有 $\leq y$ 的位置的系数求和，乘上 $y^k$，再把这些东西统统加在一起。

### P4062 [Code+#1]Yazid 的新生舞会

这道题线性做法中的“无视间隔”的意思是二阶差分数组中，这个间隔中一定是没有值的，因为跳过他的前提就是已经小于了目前的最小值，怎么也不可能有了。