---
title: 省选备战报告 第六辑 离线分治策略
updated: 2023-03-08 03:49:42Z
created: 2023-03-05 08:36:12Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

# Part 0 分治处理区间合并

一般化的问题：有一个序列，每次询问一个区间内所有元素合并起来的答案。对于一个已知答案的区间来说，可以快速追加/前缀上一个新元素，但合并两个已知答案的区间开销较大。

一般化的解决方案：对定义域进行分治，分治到的区间为 $[L,R]$ 时统一处理所有【完全包含在 $[L,R]$ 内】且【跨过 $[L,R]$ 中点 $mid$ 】的询问。

在处理 $[L,R]$ 内的上述询问时，先从 $mid$ 开始，向右挨个插入元素，一旦已经插入的元素恰好构成了某个询问区间的右半边，就把这个半区间贡献到那个询问那里。向右的进行完毕后，从 $mid$ 开始向左再进行一次。

最后对于每个待处理的询问，把刚刚的过程中先后贡献到它这里来的左右两个“半区间”合并起来。

这样，对于每个询问只需要合并一次，分治的过程中一共插入了 $n\log n$ 次。因此复杂度为

$$
O(qB + An\log n)

$$

> $B$ 为合并复杂度，$A$ 为插入复杂度。

## 猫树

数据结构“猫树”的思路与此相似，就是通过前缀和以插入代替合并，减少合并开销

# Part 1 分治处理删除单点询问整区间

一般化的问题：有一个序列，每次询问去掉一个元素后剩余的东西合并起来的答案。并且合并两区间复杂度难以接受（若可接受直接使用前缀和、后缀和），但可以迅速插入。

一般化的解决方案：维护临时答案变量，每层分治时，往左分治前先把右半区间插入临时答案；往右分治时先把左半区间加入临时答案。这样分治进行到底层时，只有当前点没有加入临时答案，剩余点都已经加入过了，因此可以直接记录答案。

## T1.0

### Tag

结论证明、01背包、退背包、分治、妙啊

难度：**MEDIUM EASY**（结论**极难**得到；其余思维简单；细节少；代码短）

## T1.1

### Tag

结论证明、分治、建图、撤销并查集、妙啊

难度：**MEDIUM**（结论难以得到；其余思维中等；细节中等；代码短）

### 题意

有一些点，横纵坐标中有一者相同的可以配为一对，求对于每一个点，去掉它后剩下的点能不能完美配对（保证总点数为奇数）

### 建图策略

一个点 $(x,y)$ 可以看做图中 $x$ 与 $y+n$ 两个点的连边。换句话说，把横坐标的每一个位置视为一个节点，纵坐标的每个位置也视为节点，一个平面上的点就是在相应的两个点之间连边。

现在问题转为抠掉一条边之后剩下的部分可不可以剖分为若干个两条边组成的链（一个点可以被多个链包含）。

### 结论

一个连通块如果有偶数条边，那么一定可以完成这一点。

证明：考虑搜索树。通过归纳法证明（假设子树成立可以推出加上父结点和连到父节点的反向边之后也成立）

关键一步：如果一个子树内有奇数条边，那么一定可以使空出来的那一条正好与（子树的）根节点相连。

最终用分治维护可撤销并查集即可。

# Part 2 时间线段树

是上面分治方法的拓宽，具体来说，把某一个操作在时间轴上的寿命分成 $O(\log n)$ 个线段树区间。然后在线段树上 DFS，同时维护一个外部的数据结构 S，进入一个点时向S中加入这些操作，退出一个点时从S中去掉这些操作。这个时候我们DFS到一个叶节点的时候，会发现现在S中的操作正好是当前时间上出现的操作。

有时候不一定在叶节点处理询问，可能在每一个节点处理询问。

# Part 3 分治处理决策单调性

决策单调性是什么？

> DP 的每一步转移都需要从一个**有序的**决策集合里面挑选决策点，若排在后面的状态的决策点永远在排在前面的状态的决策点之后，那么称此 DP 有决策单调性。

当使用分治顺序计算DP数组时，可以先暴力找出当前（DP 数组中的）区间的**中点**对应的决策集合位置，然后把决策集合分为前后两半，前半部分与 DP 数组的前半部分放在一起交给下一层分治，后半部分同理。

当然此技巧也可以用在如下问题中：

给出两个序列 $A,B$ 和一个价值函数 $\text{val}(x,y)$，要求从 $A,B$ 中各找出一个元素 $a,b$，使得 $\text{val}(a,b)$ 最大。

如果发现在最优解中，对于任何 $i>j$ ，都有【使得 $\text{val}(A_i,B_x)$ 最大的元素 $B_x$ 】在 $B$ 序列中较【使得 $\text{val}(A_j,B_y)$ 最大的元素 $B_y$ 】靠后，那么就可以使用此方法，在 $O(n\log n)$ 的时间内算出最优编组方案。

具体来说，每次先找到使 $\text{val}(A_{mid},B_x)$ 最大的 $B_x$，然后以此为界把 $A,B$ 序列各自分为两半，两个前半部分分治下去，两个后半部分也分治下去。这样每层分治都相当于通过单调性排除了一半的点。

# Part 4 基础CDQ分治

假如

# Part 5 整体二分

如果有很多询问，每个询问的答案可以通过在值域上二分得来，但是check开销较大（线性或以上），就可以通过一次计算check供给多个二分过程使用的方法优化计算。

整体二分有两种方式：

1.  同时进行许多个平行的二分（每个二分过程的mid均不一样），但是把check放在一起进行，一次处理完q个check。一般这种check会计算 $[1,mid]$ 依次合并的信息。
2.  同时进行许多个位置**完全相同**的二分（每个过程的mid都一样），计算完check之后，把应该向左继续二分的询问和应该向右继续二分的询问分开，分治下去。

## T5.0

# Part 6 笛卡尔树分治（最值分治）

简单来说，就是从序列的最值位置切成两半分治下去。

不过这样要求处理一个区间的复杂度与其长度无关，而应与分出来的较小区间的长度有关。

一个经典的技巧是从两边轮流向中间找分界点。

## T6.0

钦定进入一个区间的时候，$[l,r]$ 里面的所有数恰好被加入了一个全局集合 $S$ 中，退出时保证 $S$ 已经清空。

每次将大区间分为大子区间和小子区间时，先把小子区间里的数从集合里抠掉，然后进入大子区间的分支，回来之后因为集合已空，再把小区间的元素加回来，然后进入小区间的分支。这样集合的操作次数只和小区间有关了。

# Part 7 点分治

点分治一般用于统计树上满足某种条件的路径（点对）的数目。

当需要统计的东西可减时（如方案数目），可以先分治到子树，回来之后用所有配对方案减去两点在同一子树里面的方案

## T7.0

### Tag

点分治、凸壳

难度：**MEDIUM**（思维中等；细节中等；代码中等）

### 使用点分治化简问题

如果采用普通的暴力，那么思路将会是对于对一个点，枚举树中其他的点，找出其中距离最小的那个记为该点的答案。如果想加速这一过程，那么显然必须要想办法快速找到其他点中与当前点距离最短的那个。

如果直接使用最普通的前缀和，那么两点间的距离可以写为：

$$
\text{dist}(x,y) = S_x + S_y - 2S_{LCA(x,y)} + V_x \times V_y

$$

假如我们能用一种数据结构快速查找当前点到剩余点的距离，那么根据上式，当前点每切换一次，所有保存在数据结构中的 $S_{LCA(x,y)}$ 这一项必须修改。这势必会浪费很多时间。

所以，我们尝试变换枚举顺序来避免计算 $LCA$，而 点分治就是一种枚举 $LCA$ 的更“高明”的方法。

尝试使用点分治，在当前子树重心为 $g$，且 $x,y$ 位于不同子树内时，上式可改写为：

$$
\text{dist}(x,y,g) = S_{(x,g)} + S_{(y,g)} + V_x \times V_y

$$

> 记号 $S_{(a,b)}$ 表示 $a,b$ 路径上所有边权的和。

更进一步，因为对于同一个子树内的两点 $x,y$，它们真正的距离显然要小于刚刚定义的 $\text{dist}(x,y,g)$，所以即使当前把 $\text{dist}(x,y,g)$ 记为了 $x$ 或者 $y$ 的答案也不要紧，因为在接下来的分治中它们会被真正的答案更新掉。

这样，我们在当前层统计答案时也不必限制 $x,y$ 分属不同的子树了，毕竟以后错误答案都会被更新掉。这一步相当于把每一层的在线问题转为了离线。

### 使用凸壳维护

现在我们需要找到一种数据结构，在点分治的每一层，它可以快速插入新二元组 $(S_{(x,g)},V_x)$，并在插入完毕后对于一个二元组 $(S_{(a,g)},V_a)$ 查询它与最近的二元组的距离。

也就是

$$
\min_{(b,g)}\left\{ S_{(a,g)} + S_{(b,g)} + V_a V_b \right\}

$$

$S_{(a,g)}$ 是一个常数，可以先忽略掉

$$
\min_{(b,g)}\left\{ S_{(b,g)} + V_a V_b \right\}

$$

此时，大括号中的式子相当于用一条斜率为 $-V_a$，过点 $(V_b,S_{(a,g)})$ 的直线截 $y$ 轴得到的最小截距，可以通过在下凸壳上二分得到。

# Part 8 点分树

点分树有一个至关重要的性质：对于任意两点 $x,y$，$x,y$ 之间的路径一定经过它们在点分树上的 LCA。

x y在原树上的路径可以拆为【x与点分树上xy的LCA在原树上的路径】和【y和点分树上LCA两点在原树上的路径】两部分。

## T8.0

### Tag

复杂度分析、点分树、枚举

难度：**MEDIUM**（思维中等；细节中等；代码中等）

### 高空间复杂度做法

首先，两个点之间的距离定义为

$$
\text{DIST}(x,y) = dis_1(x,y) + dis_2(x,y)

$$

然后我们把路径从根节点处切成两半，并改变求和顺序

$$
\begin{align*}
\text{DIST}(x,y) &= dis_1(x,f_1) + dis_1(y,f_1) + dis_2(x,f_2) + dis_2(y,f_2)\\
&= (dis_1(x,f_1)+ dis_2(x,f_2) ) + (dis_1(y,f_1) + dis_2(y,f_2))
\end{align*}

$$

可以看出是两个同构的式子相加，定义新函数如下：

$$
F(x,f_1,f_2) = dis_1(x,f1) + dis_2(x,f_2)

$$

这个函数的状态空间是 $O(n\log^2 n)$ 的，可以求出来再存起来。

现在在最外层枚举 $x$ ，内层继续枚举它两树中的所有祖先 $(f_1,f_2)$，最后在刚刚的函数表里面找到 $\min_{j\neq i}\{F(j,f_1,f_2)\}$ 记为 $Res$，$x$ 贡献出的答案就是 $Res + F(i,f_1,f_2)$ .

最后一步找最小值也可以优化，对于每一组 $(f_1,f_2)$，把所有 $t$ 对应的 $F(t,f_1,f_2)$ 中最小值与次小值单独拿出来。对于枚举到的任意一个 $x$，统计【$x$ 贡献出的答案】时被采用为 $Res_x$ 的数一定是这两个值之一。

> 为什么要存次小值？因为 $F(i,f_1,f_2)$ 可能就是最小值本身，而它不能和自己配对。

这样，整体的时间、空间复杂度均为 $O(n\log^2 n)$ .

### 空间复杂度优化

刚刚解法中的空间复杂度过高，无法接受，下面尝试优化。

发现复杂度的来源是把整个 $F$ 函数的取值表都存了下来，考虑在这方面进行优化。

变换枚举顺序。最外层枚举 $f_1$ 而不是 $x$，然后在内层继续枚举 $T_1$ 中 $f_1$ 子树里每一个 $x$，然后继续枚举 $T_2$ 中 $x$ 的祖先节点 $f_2$ .

这样 $x,f_1,f_2$ 和含义与上面完全相同，并且状态空间大小也完全相同。现在再看看我们要求出来的 $F$ 函数

$$
F(x,f_1,f_2) = dis_1(x,f_1) + dis_2(x,f_2)

$$

因为现在 $f_1$ 是固定，的现在存储它只需要 $O(n\log n)$ 级别的空间了，我们需要做的是对于每一个 $f_2$，维护上面提到的最小值和次小值，最后贡献到对应的位置去。

这样，时间复杂度仍为 $O(n\log^2 n)$，空间复杂度为 $O(n\log n)$ .

## T8.1 [Codechef BTREE] Union on Tree

### Tag

虚树、点分树、计数、技巧

难度：**MEDIUM+**（思维中等偏上；细节多；代码长）

### 计数的奇妙技巧

第一步是把守卫们拉出来构成虚树。

对于原树上一个被覆盖到的点 $x$，我们先把【 “所有能覆盖到 $x$ 的点” 的**管辖范围**】涂上上红色，效果应该是这样的：

![SDOIep6img0.png](../../_resources/SDOIep6img0.png)

> 黄点是为了构建虚树加上的辅助点，橙色点是有守卫的点

发现此时所有的 “被涂上色的虚树点” 和 “被涂上色的原树边”（图中未画出） 在虚树上构成了一个**联通子图**。这是一个非常关键的性质，我们来形式化地描述一下它：

- 定义性质 $P(a,b)$ 为：从 $a$ 点出发，过程中一直在某个特定守卫的管辖范围内行走，可以到达 $b$ 点。

- 对于一个点 $x$，把所有满足性质 $P(y,x)$ 的**虚树点** $y$ 组合起来，正好构成虚树的一个联通子图。

还是不够简单。我们在虚树的每一个节点上放一个新的虚拟守卫，他管辖的范围为【这个节点上原来守卫的管辖范围】和【从其他点出来经过点之后还能继续管辖的范围】二者的最大值。

这个值记作 $d_x$，可以通过两次 DP 求出来。现在性质变成：

- 对于一个点 $x$，把所有虚拟守卫能管辖到他的**虚树点** $y$ 组合起来，正好构成虚树的一个联通子图。

好了！接下来就是技巧的部分了。

对于一个 $x$，所有【虚拟守卫能覆盖到它】的虚树节点数减去【两端的点的虚拟守卫都能覆盖到它】的虚树边数正好为 $1$ . 这也意味着，我们把每一个虚树节点的虚拟守卫能覆盖的点数加起来，减去每一条虚树边【两端节点的虚拟守卫所能共同管辖的节点数】之和，就等于我们要的答案。

> 其实就是个交换求和顺序。

点的部分是可以通过点分树轻易求出来的，重点是边的部分。

### 另一个技巧（化边为点）

对于一条边 $(x,y)$，假设 $d_x \leq d_y$，那么根据 d 的定义可以知道 $d_x + dis(x,y) \geq d_y$ . 结合这两点，根据中值定理，我们可以在边上找到一个点 $z$，使得 $d_x - dis(x,z) = d_y - dis(y,z)$ . 令 $T = d_x - dis(x,z) = d_y - dis(y,z)$，则有：

【一个点 $v$ 同时被 $x,y$ 的虚拟守卫管辖】等价于【$dis(v,z)\leq T$】，证明十分简单。

这样就可以用点分树处理全部的限制了。

> 其实还有一点小bug，就是有时候因为奇偶性问题可能找不到这个 $T$，不过这不要紧，让式子两边差得尽可能小之后取较小的那一边作为 $T$ 就行了。

## T 8.2

### 题意

有一个带权树，现在定义一个完全图，图中两个点 $x,y$ 之间边的权值为树上 $x,y$ 两点的路径长。求此完全图大小为 $m$ 的最大权匹配。

### Tag

点分树、结论证明

难度：**MEDIUM**（思维中等；细节少；代码中等）

### 转化问题

假设已经选好了 $2m$ 个用来匹配的点，现在需要考虑求出它们的具体匹配情况。对于树上的一条边而言，它会把树分成两侧。不妨假设两侧的匹配点数目分别为 a,b，那么这条边产生的贡献最大是 w\times \min\{a,b\} . 所以我们尽量让每一条边产生的贡献都是此值。

考虑求出

### 引理

考虑把根节点改为某个一级子树中的某个点会不会让答案变得更优秀。

感性理解，转移进某个一级子树会变得更优的必要条件是这个子树中最大的 m 个点最终都被采用了（也就是这个子树独占了 m 个匹配点）。

为什么呢？因为这有这样，限制该子树在换根前对整体答案的贡献的是【一个一级子树只能有最多 m 个点参与最终的选取】而不是【最终在所有子树提供的备选点中挑出 2m 个最大的】。所以遇到了这种独占了 m 个点的子树，使他发挥出更大效益的做法就是把根转移进它里面。

理性证明，假设某种情况下有个一级子树里面的匹配点个数严格小于 m，但是把这个子树里面的某个点 y 作为新的根节点之后变得更优了。这种假设情况下，y子树（原来的树中以 y 为根的子树，现在变成了一个一级子树）中第 m 大的点**必定大于等于**剩下的部分里第 m 大的点

> 为什么呢？因为如果

# Part 9 边分治

对于一些菊花数进行边分治的时候，可能需要通过建立虚拟节点把菊花数转化成二叉树。

边分树的每一个非叶子节点都是一条边的形式。

边分树的每一个子树中所有的叶子节点在原树上一定联通。

原树中两点之前的路径一定经过它们在边分树上的 LCA 。

# Part A