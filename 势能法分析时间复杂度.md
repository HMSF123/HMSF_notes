# Part 0 基础概念

在一些数据结构题目中，操作所耗费的时间复杂度不是平均的，会与数据结构的形态相关，但是所有操作的平均复杂度可以被计算出来。这种情况被称为**均摊复杂度**，一般使用势能法进行分析。

势能法可以获得一个均摊复杂度的上界。

“势能”是一个虚拟的量，有的时候，我们令操作在自己真实的开销以外预支一些额外的开销，称作势能，并把这些势能保存起来。有的时候，我们把先前的势能拿出来，用以抵消现在操作的开销。

> 某一时刻的势能是可以为负数的

进行过上述预支、抵消后得到的时间开销称为**摊还代价**，记作 $T_x$

> 如果分析得当，得到的摊还代价都是容易求和的形式（或者全部相等）。如果不易求和说明分析失败了。

如果我们发现，进行完所有操作之后，剩下的势能非负，那么我们相当于保证了：【消耗势能的操作】所用的势能一定来自【前面积攒的势能】，或者【后面偿还的势能】。

也就是说，就算某个操作要耗费复杂度，他所“耗费的复杂度”都是前面已经耗费过一次的复杂度的复制（或者势能小于零的情况下，是后面补偿的复杂度的复制）。由于渐进复杂度不考虑常数倍数，所以这一些复杂度被消耗几次其实无所谓。于是可以消去后面的复杂度，只计算前面的。（这也是用势能抵消复杂度的原理）

综上，保证整个过程中势能变化非负的话，把所有操作的摊还代价求和，就是一个真实代价的上界。

形式化的，我们定义一个势函数 $\Phi(D_x)$ 表示数据结构 $D$ 在时间 $x$ 时的版本的势能储备；令第 $x$ 次操作的**真实时间开销**为 $C_x$ .

那么第 $x$ 次操作的摊还代价 $T_x$ 就可以表示为 $C_x+\Phi(D_x)-\Phi(D_{x-1})$ .

对所有摊还代价求和，得到 $\sum T_x = \sum C_x +\Phi(D_N) - \Phi(D_0)$ .

>这样也看出了若保证势能总变化非负，摊还代价是真实代价的一个上界。

如果我们把势函数定义得非常宽松，每次增加势能的时候一下增加一大堆，用都用不完，那么我们会得到一个相当松的上界；如果反过来定义的很紧，每次恰好把剩下的势能用完，那么得到的就是一个很紧的上界。

综上，我们得到的复杂度上界取决于我们定义的势函数，我们希望他尽可能的紧，每次新增的势能都能用完。

# Part 1 例题

## 双端栈维护 01 背包

一个滑动串口在序列上向右滑动，有时候从右侧加入物品，有的时候从左侧弹出物品。动态维护滑窗的 01 背包数组（维护最小价值而非方案数）。

考虑只能退掉最后一个物品，采取以下方法：使用方向相反的两个栈维护序列，当左侧的栈被弹空的时候将右侧栈平均地一分为二，暴力压进两个栈里面。

定义势能函数 $\Phi$ 为【右侧栈的长度减去左侧栈长度】乘上背包容量 $w$ .

- 增加物品操作的摊还代价为 $T = C+(\Phi+w)-\Phi = w+w = O(w)$ .
- 删除物品（不引发重构）的摊还代价为 $T = C+(\Phi+w)-\Phi = w+w = O(w)$ .
- 删除物品（引发重构）的摊还代价为 $T = C+(len\mod 2)w-(len\times w) = len\times w-len\times w+(len\mod 2)w = O(w)$ .

注意到每次重构使得左右等长（如果是奇数，不妨令右侧稍长），并且在下一次重构前，右侧只会变长，左侧只会变短，因此最终势能一定非负。

可以看到操作的摊还代价均为 $O(w)$，因此总复杂度为 $O(nw)$ .

## 后缀自动机增量更新

