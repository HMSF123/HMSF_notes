# T1

暂且不写

# T2 CF1250D

难度：**HARD**

考虑把每个区间染上它的颜色，如果一个格子被染了两次不同的颜色就变成杂色。那么答案就是所有被完全包含在纯色连续段内的区间数目。

考虑我们其实是在求最大值，我们大可以直接钦定纯色连续段是某种情况，判断是否合法后再贡献到答案里面即可。

考虑DP的同时钦定最后一个连续段的左右端点、染的颜色。虽然我们有可能钦定出来的不是最优解，但是由于这道题不要求计数，只是求最大值，那么劣解最终也会被更新掉。

这里有一个究极炫酷的技巧！

考虑我们怎么样才能确定一个转移是合法的。

1. 新钦定的连续段里面，所有已经染好颜色的点与它颜色相同。
2. 如果新钦定的连续段和我们所在的连续段颜色不同，不存在一个区间，跨过 $r$ 和 $l'$ .

这两个限制所要求的参数分别为：

1. $l',r',k'$
2. $r,l',k'$

分别只有三个限制。

我们考虑，可以把转移分成两步，每一步单独的时间复杂度都是 $O(n^3)$ .

记录一个中间的三维数组 $g_{l',k',0/1}$，表示仅仅满足第二条限制时，转移出的答案.最后一维表示是“钦定不能为 $k'$” 还是 “钦定必须是 $k'$”

首先我们枚举 $l'$，$g[l',k,1]\leftarrow f[r,k]$ 当且仅当【 $k'\neq k$ 且 $\nexists (L,R),L\leq r,R\geq l'$ 】时进行。

$g[l',k,0]\leftarrow f[r,k]$ 当且仅当【 $k'=k$ 】时进行。

然后我们在处理后面的状态$f[R,K]$时，先枚举它最后一个钦定出来的连续段可能的左端点，对于所有满足限制一的 $L$ 端点位置，从 $g$ 里面挑出来转移即可。

> 注意，$f[r,k]$ 可以从 $g[l',k'],k'\neq k$ 的地方转移过来，需要对前缀、后缀求一个 $\max$

$g$ 不用清空，因为前面提到的原因，劣解是会被刷掉的。

这个技巧的本质相当于把一个筛选分成两步完成。

> 一个坑：是不是可以通过调整转移结构来达成同样的效果

```cpp
for(r)
{
	for(k)
	{
		for(rr) f[rr][k]
	}
	for(kk)
	{
		for(rr)
	}
}
```

# T3 CF1158F

难度：**MEDIUM EASY**

考虑如何判定一个段的密度，我们每次调到最靠后的第一次出现的字符，当字符集不全时退出，跳的次数就是答案。

方案数的话，对于每两次跳的间隔这一段的每个字符求一个非空子集数目就行了。

仍然是平衡复杂度的套路。DP需要处理类似连续段一样的东西，所以我们有两种转移的策略：

- 每次转移一整个连续段。由于值域的限制，最多划分出 $O(n/c)$ 个连续段。所以状态应该为 $O(n^2/c)$ 级别的，但是转移需要 $O(n)$ 的时间。值域越大我们越赚。
- 每次转移一个格子。这样转移是 $O(1)$ 的，但是状态中需要额外记录一个维度来表示现在这个“未完成”的连续段的信息。具体来说，状态是 $O(n^22^{c})$  级别的。显然值域越小我们越赚。

那就平衡这两个策略，发现平衡最劣复杂度为 $O(n^{3}/\log n)$ .

# T4 CF1175G

我想的做法利用了最值分治，一会再补

难度：**MEDIUM EASY**

关键点在于，如果我们可以通过拆分序列的方法得到若干个连续段，那么可以在连续段外和连续段内两个层次分别快速更新信息。

写出暴力的转移方程：

$$
f[i,j] = \max_{k\leq i}\big\{f[k,j-1]+(i-k)\times \max_{x\in[k+1,i]}\{a_x\}\big\}
$$


观察到最后一项是个后缀最大值的形式，存在均摊（单调栈弹栈最多 $O(n)$ 次），那么可以尝试对于每个连续段，维护这个连续段贡献的答案（是一个凸包上切线的形式），然后再开一个DS维护所有连续段对位置 $i$ 的贡献（是一些一次函数）中，我们该选取哪个（是一个可撤销李超树，因为我们每次弹栈对应的是两个凸包的合并和重新切线，并且合并的这两个凸包一定是最后增加的）

> 可撤销李超树怎么搞？我们把每次操作对数组某个位置的更改记录在一些栈里面（记录的是更改前这个东西的状态），然后暴力弹栈就可以了。
> 
> 你说为什么不会超时？
> 
> 均摊均摊均摊

# T5 Luogu P9312

难度：**HARD**

> 这道题里面涉及的状态设计技巧真的很丰富。
> 
> 做过第二爽的DP题。

首先考虑最朴素的DP：设计状态 $f[l,r,msk]$ 表示目前能够走到的下标区间是 $[l,r]$，买了的灯笼覆盖了海拔上 $msk$ 这个集合的情况下，走完全部山脉最少还需要多少钱。至于转移，方程可以是：

$$
\begin{gathered}
f[l,r,msk] \overset{\min}{\leftarrow} f[l-1,r,msk] \quad(h_{l-1}\in msk)\\
f[l,r,msk] \overset{\min}{\leftarrow} f[l,r+1,msk] \quad(h_{r+1}\in msk)\\
f[l,r,msk] \overset{\min}{\leftarrow} f[l,r,msk\cup[L_k,R_k]] \quad(p_k\in [l,r])\\
\end{gathered}
$$

当然这么搞非常没有前途！

考虑如何化简状态。我们从 $msk$ 这一个维度下手，因为数据范围不可能让维度中出现状态压缩这种东西。

我们为什么要记录 $msk$ 呢？是为了在转移的时候看看自己能不能走到左边/右边的一个新的位置。那我们可不可以仅记录目前购买的灯笼中，照到的上界 $T$ 和下界 $D$ 呢？

答案是肯定的！不过不是记录 $msk$ 的上下界，而是假设目前能够走到的海拔区间是一个连续段，记录它的上下界。因为我们不在乎走的路程，只在乎花掉的价值，完全可以把目前暂时没用的灯笼拖到后面买。

> 可以看做通过去除无用行动化简接口信息。保证DP中，行动只有一种顺序出现。

现在我们的状态变成了 $f[l,r,D,T]$ 已经可以获得一些暴力分数了。

可不可以进一步简化？

发现如果规定了海拔区间 $[D,T]$ 后，我们的序列中会有若干个下标上的连续段合法，我们只需要记录起点 $st$，顺便预处理出每一个状态 $[D,T]$ 对应的下标区间，就可以再优化掉一个维度了。

能不能再给力一点？

**观察发现**，我们记录 $[D,T]$ 所包含的信息量其实不如记录 $D,T$ 是由哪两个灯笼贡献的，因为后者还包含了序列下标的信息，可以用来节省掉 $st$ 这个维度。

现在状态为 $f[u,v]$，表示 $u$ 这个灯笼贡献了下边界，$v$ 这个灯笼贡献了上边界，此时走完全部山脉还需要多少钱。

> 当然，需要预处理出某个状态是否合法、一对 $[u,v]$ 对应了哪一个下标区间。
> 
> 看上去这似乎比DP的本体还要困难，但是我们可以舍弃一些条件，比如我们可以不要求这个区间里面可以买到刚好覆盖整个海拔区间的灯笼。
> 
> 换句话说，我们统计的是“令海拔上界为 $R_v$，下界为 $L_u$，在所有满足【海拔全部位于这一区间里面】的连续段中，包含了 $p_u,p_v$ 的那一个，如果没有，则该状态非法”。
> 
> 这样不会导致错误。首先，对于一个合法的状态而言，这样得到的位置区间正好就是我们希望得到的位置区间（额这句话好怪）。其次，在位置区间逐渐缩小的时候，那些本来非法但是被算作合法的区间，总会有一个时候无法发生转移，因而不对答案产生贡献。
> 
> 技巧：允许非法状态存在，但不让它转移到底。

然后我们就可以快乐地转移了！

记住我们一开始的假设！每次选择一个贡献了新上界/下界的灯笼的时候，它所照亮的海拔区间必须和原有的区间相交。

$$
\begin{gathered}
f[u,v] \overset{\min}{\leftarrow} f[u,w]+c_w\quad(R_w>R_v,L_w\leq R_v,p_w\in Intv_{(u,v)}) \\
f[u,v] \overset{\min}{\leftarrow} f[w,v]+c_w\quad(L_w<L_u,R_w\geq L_u,p_w\in Intv_{(u,v)}) \\
f[u,v] \overset{\min}{\leftarrow} f[w,w]+c_w\quad(R_w>R_v,L_w<L_u,p_w\in Intv_{(u,v)}) \\
\end{gathered}
$$

最后一件事情就是敲定转移顺序。

一个DP转移顺序不会导致错误的充要条件是什么？

是对于每一个状态，当他被转移的时候，它的所有前驱状态都已经被转移过了。

所以我们按照海拔区间的长度由大到小转移即可。

如何做到这一点？

$2k$ 个独立的扫描线，前 $k$ 个固定左端点从大到小扫右端点，后 $k$ 个固定右端点从小到大扫左端点。由大到小枚举待转移海拔区间的长度，一步步转移即可。

> 这里的“左右端点”指的是照到下界/上界的灯笼。

为了判定 $w$ 是否在 $f[u,v]$ 对应的位置区间里面，所以我们对于每个扫描线还要开一个线段树维护位置区间。把所有的前驱状态放在线段树里面对应的位置上，那么转移相当于一个区间查询最小值。

由于移动端点缩小到一定程度之后，有的 $w$ 会因为不再和当前区间相交而无法产生贡献，这时候这个贡献就死掉了。为了避免尸体产生错解，还要及时移除线段树里面死掉的节点。

对于第三类转移，我们可以把它拆成 $[u,v]\to[u,w]\to [w,w]$，因而要允许 $R_u>R_v$ 的状态存在，并且还要先转移扫右端点的部分，再转移扫左端点的部分。

> 对于这类状态，其对应的海拔区间仍然是 $[L_u,R_v]$ .

这里其实还能继续优化！

以处理右端点的扫描线为例，我们发现不仅海拔区间单调减小，位置区间也是单调不增长。

> 为什么？因为允许的海拔范围不断缩小，但是仍然必须包含 $u$ 这个点。

所以我们一旦发现数据结构里面的一个后继状态无法更新当前状态（无论是什么原因），直接把它从数据结构中剔除掉就可以了。

我们不用开线段树，而是用 $2k$ 个小根堆，每次发现堆顶无法更新当前状态就弹掉。

这样这道题就做完了。