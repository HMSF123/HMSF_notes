今天下大分
# T1
`N[msk]` 表示以 `msk` 这个状态（已经在路径上的点）为起点，能走到的点。

哈密顿回路是可以调整的，详细可见UOJ的调整法博客。

设计状态 `f[msk][s]` 表示从 s 出发，经过msk中的点且仅经过一次后能达到的点的集合

发现状态转移的过程中 s 基本不会被使用，所以钦定一个特殊点，把哈密顿路砍成两半，问题转化成从特殊节点走出两条不相交的路径，并且二者的并集是整个点集。

然后设计状态 $f[msk][x]$ 表示包含 msk 中的点，存不存在以 x 结束的路径。

# T2

考虑用一般的套路，然后可以观察到对于一个连续区间，进来的血量-出去的血量构成的函数图像一定是一段无定义（死了）；一段是常数，一段是斜率为 $1$ 的直线。

为什么是这样的呢？

考虑没有关卡，那么这个函数就是一个最普通的一次函数。然后考虑在后面追加操作：

- 扣血操作：整体向下平移，会产生一段死掉的，和一段平移后的一次函数。此时函数里面如果有平着的，将不会受影响。
- `checkMin` 操作：找到函数和平线的交点，后面的拍平，前面的死掉。此时函数变成两段，一段死了，一段平着的。
- `checkMax` 操作：找到函数和平线的交点，下面的拉上来拍平，上面的保持不变。此时平的只能变成平的，斜的要么不变，要么变成平的。

三种操作都不会让函数的”阶梯“增加，所以直接使用线段树维护分段函数复合。

# T3

如果一次只能操作一个，那么毫无疑问，最优的操作就是依次向后加上（因为一个位置至少要被加上一次）。

然后考虑一次可以进行四个平行的操作，答案理应是严格大于 $\frac{n}{4}$，不大于 $n-1$ 的。

不能直接简单地线段树式合并，因为这需要无穷多个进程。

而我们只有四个进程，一次可以对长度为 $8$ 的一个区间进行线段树式合并。

那么我们在序列的最底层没 $8$ 个元素编成一组，合成完毕之后，把这里面的最后一个元素贡献给下一个长度为 $8$ 的组，再故技重施，直到结束。

这样可以得到 `59pts`

正解太高了，完全听不懂。