---
title: Tarjan 算法的细节
updated: 2023-03-19 09:52:56Z
created: 2023-03-19 09:17:05Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

首先，要明确判定割点、v-DCC的条件都是 `low[v]>=dfn[u]`。OI-Wiki上的写法其实是更改了 `low` 数组的定义，不必奇怪。

然后我们仔细考虑一下上面的条件其实只有两种情况：

1. `low[v] == dfn[u]`，这意味着 $u$ 是某个环中的一个节点。
2. `low[v] == dfn[v]`，这意味着点 $v$ 所在的 v-DCC 其实只有两个节点：$u,v$ .

第二种情况为什么会成立呢？因为如果 $v$ 是环中的一个点的话，它早就被移出栈了。

然后我们考虑，如果不仅要求 v-DCC，还需要求割点，那么对于一般的节点，只要满足 `low[v]>=dfn[u]`，我们就可以直接断定它为割点，但对于根节点，我们还需要确保它有至少两个儿子。

另外记住，在求 SCC 时，我们判定一个点及其子树为一个强连通分量的条件是 `low[v] == dfn[u]` 。

然后谈谈这个时候的横插边。这里有一个被无数篇博文无数次提起的问题：

**“必须直接用横插边终点的 `dfn` 更新 `low[u]`，而不能用横插边终点的 `low` 更新 `low[u]`。”**

从结果的正确性方面来说，这条法则其实没有必要存在。而如果从算法的基本思想来说，这一条需要严格遵守。

为什么？

首先我们考虑横叉边的性质。

为什么会出现横叉边？本质上是因为我们遍历到一条边的时候发现它的终点之前已经被遍历过了，并且因为这是条有向边，早些时候搜到终点的时候没法反过来搜这个子树，所以就出现了横叉边。

进一步，我们可以知道横叉边永远从后来搜索的子树连向之前搜索过的子树。

接下来，我们分两种情况讨论：

1. 横叉边终点 $v$ 的 `low` 值小于 `low[lca(u,v)]`。这种情况下，无论如何也找不出一条能从 $v$ 回到 $u$ 的路径（如果有，那么这条路径的存在会使得 `low[v]>=low[lca(u,v)]`）。

   所以此时横插边本身就是连在两个 SCC 之间的 DAG 边，进而可以得出它的终点所在的 SCC 已经被记录过一遍并弹出栈了，所以这条横叉边的终点**一定不在**栈中，讨论如何用它更新 `low[u]` 显然也没有意义。
2. 