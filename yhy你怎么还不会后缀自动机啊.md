---
title: yhy你怎么还不会后缀自动机啊
updated: 2023-03-16 02:10:16Z
created: 2023-03-11 09:38:14Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

# Part 0 SAM

## § 0.1 SAM的由来

SAM是什么？

短点儿的答案：

SAM是把特定节点捏在一起的后缀树。

长点儿的答案：

你先别急，先定义个有用的东西：

**终点集**：一个长长的字符串有很多子串，一个子串可能会在母串不同的位置出现很多次，这些出现位置的终点的集合叫做终点集。某个子串 $S$ 的终点集记作 $endpos(S)$ .

这个东西能引出来三个定理：

1. 两个终点集相同一定可推出一个子串是另一个的后缀。
2. 两个终点集要么包含，要么相离，不可能相交一部分。
3. 对于一个终点集，这里面包含的所有子串的长度一定覆盖一个连续区间。

> 证明：
> 
> 1. 不然呢？对于一组终点来说，在这里结束的两个长度不同的串肯定有一方是另一方的后缀。
> 2. 如果两个终点集有交，由上面的定理可得其中一个对应的子串必然为另一个的后缀，那么长点的那个一旦出现，短点的那个也会在同一位置上出现，不可能有某个位置仅为长串的终点而不是短串的终点。
> 3. 对于一个子串而言，它的后缀的终点集大小不会小于他，因此得证。（也就是说如果长子串的某个后缀可以在别的地方有一个终点，那么比这个后缀更短的后缀也会在这个地方出现，不可能又回到一开始长子串的终点集）

根据上面的证明3，我们再定义一个比较有用的东西：**后缀链接**。

具体来说，对于一个子串，我们不断把它缩短（删去首字符），那么这个串的终点集大小一定是单调不降的，换句话说，去掉这个串的第一个字符时，终点集的大小要么不变要么变多。对于每一次集合大小的扩充，我们从之前的终点集画一条出边连到这个新的终点集。这条出边就叫做**后缀链接**。

他有这么两个性质：

- 所有后缀链接必定形成一棵树。
- 后缀链接形成的树一定也是终点集形成的树（母集合连向若干个不相交、全覆盖子集）。

> 第一点的证明很简单，因为后缀链接只从较小的终点集连向较大的终点集，所以一定会形成一棵树。后者就更不用证明了。

还有最后一个东西要定义：

我们把所有终点集完全相同的子串放在一起，称作一个**后缀等价类**。这是一个非常关键的概念（刚刚构建的那棵后缀链接树中的节点就是一个后缀等价类）。

现在来说说什么是SAM吧！

后缀自动机是一张图，每条边的边权是一个字符，节点中有一个初始状态，从这个点走出的任意一条路径都对应着原字符串的一个子串。并且SAM是满足上述条件的图中最小的一个。

看到这个条件，我们首先会想到后缀树对吧。毕竟一个子串就是一个后缀的一个前缀，后缀树上的一条根链就是后缀的一个前缀。但是后缀树上的一条边不一定是一个字符。

我们把压缩前的后缀树写出来，称呼他为“伪后缀树”，下文中的“后缀树”均指伪后缀树。

但是展开后我们面临了新的问题，伪后缀树不一定满足上面所说的**最小性**。

为什么呢？假如说有一个子串 A 和另一个子串 B，并且【这两个子串在伪后缀树上对应的子树】的结构是完全相同的，那么可以把这两个节点捏在一起，**使他们共用同一个子树**，而依然满足从根开始的任意一条路径都是一个子串的性质。

那么怎么样构建一个满足最小性的图呢？

容易想到一种思路，把伪后缀树的所有能捏的节点捏在一起，最后得到的DAG一定满足最小性。

> 证明：假如不满足最小性，那么就等于说有两个点，它们本来可以写为同一个点，但是分开了。考虑两点能写为同一个点的充要条件是从这两个点出发的所有路径都相同，而这样的两个点正好是可以捏到一起的。

那么这张DAG上的节点有什么意义呢？

考虑在原来的伪后缀树上，“从一个点 $x$ 开始，往它的子树里面走”这个动作在原字符串上代表什么？当然代表的是从【 $Rootchain(x)$ 所对应的子串】在原串中的**终点集**里的某个位置开始，在原串上往后走。

> 感性理解一下，“在原串上向后走”和“在伪后缀树上向下走”两个动作是一致的。

那么如果有两个节点 $A,B$，他们的子树完全相同，这意味着什么呢？

没错，从 $A$ 或 $B$ 出发，能得到的子串完全相同。结合上面关于终点集的论述，刚刚这句话也可以表述为：

【从 $endpos(Rootchain(A))$ 中的每个位置出发，向后走任意长度的过程中，你的足迹标出的所有子串组成的集合】与【从 $endpos(Rootchain(B))$ 中的每个位置出发，向后走任意长度的过程中，你的足迹标出的所有子串组成的集合】这两个集合是**完全相同的**。

而这只对应了一种可能—— $endpos(Rootchain(A)) = endpos(Rootchain(B))$ .

没错！融合后的节点正是一个**后缀等价类**！

> 这里注意一下，实际情况下可能有三个或者更多节点融合为一个。

进一步可以推出，所有能融合的节点融合完毕后，新图恰好包含了**所有**后缀等价类。

正好，我们可以把前面提到的“后缀链接树”叠加到这张图上，这样图里面有了两类边：来自伪后缀树的**转移边**，和来自后缀链接的**后缀链接边**。

这个东西就是SAM了！

每个点需要维护这些东西：

- 这个后缀等价类的最小、最长子串长度 $minlen(x)$ 和 $maxlen(x)$ .
- 这个点在后缀链接树上的父子节点。
- 这个点的入边和出边。

并且还有四个性质：

- 对于SAM中的一条转移边 $(u,v)$，一定有 $maxlen(v) > maxlen(u)$ .
- 对于一条转移边 $(u,v)$，【$u$ 所对应的终点集】整体向右移动一位后包含【$v$ 所对应的终点集】.
- 沿着后缀链接树往上走， $maxlen(u),minlen(u)$ 递减，且 $minlen(u) = maxlen(fa(u))+1$ .
- 仅有一个点入度为零，仅有一个点出度为零。

> 证明：
> 
> 1. 考虑【被捏到 $u$ 里面的所有原后缀树点】组成的集合，一个【被捏进 $v$ 里面的原后缀树点】一定是这个集合里某个点的儿子。所以对于 $u$ 中的每一种子串长度，$v$ 中都一定有一个更长的与之对应。
> 2. 一旦加了一个字符之后的字符串出现，那么少了一个的也必定出现。
> 3. 根据后缀链接树构建方法易证。
> 4. 根据构造方法易证。

> 顺便这里还要说一个可能没什么用，但对于理解转移有一定帮助的细节：
> 
> 首先要明确后缀自动机上的一个点代表了什么：
> 一个后缀等价类、与此等价类对应的终点集、此等价类包含的一些长度连续的子串。
> 
> 然后我们考虑沿着一条**转移边**走一步在原串上的意义：
> 
> 假如说我们从点 $x$ 出发，沿着一条字符为 $c$ 的转移边走到了点 $y$，那么在原串上我们相当于从【$x$ 所代表的终点集】中的**某一个**位置 $a$ 出发，向右走一格后到达一个写着字符 $c$ 的位置，而 $y$ 节点对应的就是包含 $[a-maxlen(x)+2,a+1]$ 这个串的后缀等价类。
> 
> 最后，沿着后缀链接向根走相当于遍历一个串的后缀。

## § 0.2 SAM的构建

一般采用增量构建的方法来构造SAM，具体来说就是每次在原字符串后面新增一个字符，并对SAM进行调整。

假设我们新插入的字符为 $c$，下面详细解释一下算法步骤：

如果是一棵后缀树的话，增量更新是简单的：对于每一个原串的每一个后缀所对应的点，在这里新增一个字符为 $c$ 的转移，链接到一个新建的状态。

但如果是后缀自动机的话，那些需要添加新转移的点应该是满足【对应的终点集含有“原串尾”这个位置】的所有点。

这些点在哪里呢？在后缀链接树上【表示整个字符串的点】的根链里。

考虑到这一点，我们可以知道算法的前两步：

1. 找到原先DAG中对应“整个原串”的那个节点 $x$，在它后面添加一个字符为 $c$ 的转移，链接到我们新建的一个状态（暂且叫他 $cur$）。顺便初始化 $maxlen(cur) = n+1,minlen(cur) = minlen(x)+1$ .

> $n$ 是添加新字符前原串的长度。

2. 我们不断通过 $x$ 的后缀链接往上跳，假如说跳到的这个点 $p$ 还没有字符为 $c$ 的转移，就直接连一条出边到 $cur$ 这个点，并令 $minlen(cur) = minlen(p) + 1$ .

> 注意此时还不能确定 $link(cur)$ 指向哪里。

但是如果 $p$ 本身就有了一个字符为 $c$ 的转移该怎么办呢？假设这个转移到的点为 $q$，我们考虑两种情况：

- $maxlen(q) = maxnlen(p) + 1$：这种情况下，我们知道 $q$ 对应的终点集正好就是【 $p$ 对应的终点集中的每一个位置】在原串上向右移动一个位置得到的。
  
  而既然都这样了，那么我们直接在 $q$ 的终点集里面塞一个 $n+1$ 也没有什么不妥。所以直接令 $link(cur) = q,minlen(cur) = maxlen(q)+1$，然后**退出算法**。
  
  > 为什么直接退出？因为这种情况下， $p$ 在后缀链接树上的祖先也一定都有一个字符为 $c$ 的转移，连向 $q$ 在后缀链接树上的某个祖先。

- $maxlen(q) > maxnlen(p) + 1$：因为我们是按照 $maxlen$ 从大到小遍历 $p$ 的，所以遇到这种情况时，对于任意一个【比 $maxlen(p)$ 更长的原串后缀】这个子串，它在其他地方出现的时候，后一个位置绝不会是 $c$ .
  
  因此，$[n-maxlen(q),n+1]$ 这个子串与任意一个形如 $[x-maxlen(q)+1,x]$ 的子串都绝不相同。也就是说包含 $[n-maxlen(p)+2,n+1]$ 这个子串的后缀等价类的 $maxlen$ 一定是 $maxlen(p)+1$ .
  
  综上，我们需要把 $q$ 这个状态裂成 $t$ 和 $q'$ 两半，具体来说，二者的出边完全相同，但是 $minlen,maxlen,link$ 改为如下量：
  
  $$
  \begin{gather*}
\begin{cases}
   minlen(t) = minlen(q)\\
   maxlen(t) = maxlen(p)+1\\
   link(t) = link(q)
\end{cases} \\ ~ \\
\begin{cases}
   minlen(q') = maxlen(p+2)\\
   maxlen(q') = maxlen(q)\\
   link(q') = t
\end{cases}
\end{gather*}
  $$
  
  然后我们令 $link(cur) = t$，并遍历 $p$ 在后缀链接树上的祖先，一旦有祖先有连向原来 $q$ 的转移，就把这个转移重定向到 $t$。最后退出算法。
  
  > 为什么只改祖先的而不改其他的？因为只有祖先节点所对应的终点集里面包含原串的串尾位置。

以上就是线性构建SAM的全部步骤了。下面提供我的代码：

```cpp
void ExtendSAM(int c)
{
    int cur = ++tot;
    int p = lst;
    maxlen[cur] = maxlen[lst] + 1;
    while(p!=-1 && ch[p][c] == 0) { ch[p][c] = cur; minlen[cur] = minlen[p] + 1; p = link[p]; }
    if(p==-1) {link[cur] = 1;}
    else
    {
        int q = ch[p][c];
        if(maxlen[q] == maxlen[p] + 1) { link[cur] = q; }
        else
        {
            int t = ++tot;
            for(int i=0; i<26; i++) ch[t][i] = ch[q][i];
            link[t] = link[q]; maxlen[t] = maxlen[p] + 1; minlen[t] = minlen[q]; minlen[q] = maxlen[p] + 2;
            while(p!=-1 && ch[p][c] == q)
            {
                ch[p][c] = t;
                p = link[p];
            }
            link[q] = link[cur] = t;
        }
    }
    lst = cur;
    return;
}
```

> 运行上述代码前记得初始化 `link[1] = -1` .

等等，你说是线性的这就是线性的？我不信。

好，那我们证明一下增量构建SAM的总复杂度是 $O(n)$ .

首先容易观察到，复杂度主要取决于以下四个操作：

1. 新建 $cur$ 节点。
2. 遍历 $lst$ 在后缀链接树上的祖先。
3. 分裂状态 $q$ .
4. 分裂 $q$ 之后，遍历状态 $p$ 的祖先。

其中，操作 $1,3$ 每次增加新字符至多总共进行两次，所以不是复杂度瓶颈。

而操作 $2,4$ 看起来就非常的 **SUS**，每次遍历根链似乎是 $O(n^2)$ 的。怎么办呢？

定义 $FinalPos(i)$ 表示第 $i$ 个字符插入完毕后，【$link(cur)$ 所代表的等价类中最长子串】最后一次出现的位置。

> 这句话有点绕，具体来说就是 $i-maxlen(link(cur))+1$ 的值。

$p$ 的初值为 $lst$，而第 $i$ 轮的 $lst$ 其实就是第 $i-1$ 轮的 $cur$，同时我们知道除非是第一次，否则每次插入新字符时 $p$ 至少上跳一次。所以一定有

$$
maxlen(link(cur_{i-1})) = maxlen(link(p_{\text{初}})) \geq maxlen(p_{末})
$$

接下来，考虑到算法中 $maxlen(link(cur))$ 要么是 $0$（当且仅当 $link(cur)=1$），要么是 $maxlen(p)+1$ . 分类讨论：

- $maxlen(link(cur))=0$ 的情景是平凡的，此时一定有 $maxlen(link(cur_{i-1})) = maxlen(link(cur)) = 0$ .

- $maxlen(link(cur)) = maxlen(p_{末})+1$ 的情景中，上式变为

$$
maxlen(link(cur_{i-1})) -1 \geq maxlen(link(cur))
$$

综上，$FinalPos(i) \geq FinalPos(i-1)$，而且所有的操作 $2$ 本质上都是使 $FinalPos(i)$ 增加，所以操作 $2$ 的总复杂度为线性。

~~操作 4 还不会证，咕了。~~

## § 0.3 SAM的典型应用

### 判断是否出现

判断一个串 $P$ 是否在 $T$ 中出现。

对 $T$ 建出后缀自动机，把 $P$ 放进去走，如果能够每一步都有对应的转移，能够顺利走完，那么 $P$ 是 $T$ 的一个子串；而如果走到某一个位置之后走不下去了，那就说明 $P$ 不是 $T$ 的子串。

当然，在走的过程中，我们还求出了 $P$ 在 $T$ 中出现的最长前缀长度。

### 求任意子串出现次数

第一，对于一个后缀等价类，里面所有的字符串的出现次数都是相等的。

因此，我们只需要对于每一个后缀等价类计算其终点集大小。

第二，后缀链接树上任意一个节点的点终点集大小等于其所有子节点的终点集大小之和。

这一点可以用终点集的性质轻松证明。

因此，我们只需要对于后缀链接树上的每一个叶子结点 $+1$，然后做一次DFS，每次把子节点权值求和就可以了。

> 博主血的教训：不能一边构建一边统计这个东西。因为如果在构建的时候计算每个 $endpos$ 的大小的话，每次插入都必须 $O(n)$ 更新完所有祖先的 $endpos$ 大小。

### 求本质不同子串个数

有两种方法：

一：考虑到不可能有两个本质相同的字串出现在两个不同的后缀等价类中，所以每个节点所包含的本质不同子串数量为 $maxlen - minlen + 1$，对于所有节点求和即可。

二：一个子串相当于从根开始的一条路径，SAM是一张有向无环图，DP统计路径条数即可。

### 本质不同子串的总长

就是上面那一问加了点小小的修饰。

一：可以对于每个点求和 $\frac{(maxlen+minlen)\times(maxlen-minlen+1)}{2}$ .

二：DP的时候记录一个“从该节点出发的所有路径的总长”，每个点的该值由对所有子节点求和【从此点出发的路径数目+从此点出发的路径总长】。

### 字典序第 $k$ 大

仍然是上面那一问，做完之后直接搜就行了。

> 这都字典序了，还用啥SAM啊，直接写SA不就行了。

### 求首次出现位置

求一个串 $P$ 在 $T$ 中首次出现的位置。

每次增量更新的时候维护一个新的值 $firstpos$，指当前点的终点集中最靠前的位置。

每次新建一个状态 $cur$ 时令 $firstpos(cur) = n+1$，裂开一个状态的时候令 $firstpos(t) = firstpos(q') = firstpos(q)$ .

> 因为状态 $t$ 所包含所有子串都是 $q'$ 所包含的所有子串的后缀，而 $t$ 中的子串第一次“单独出现”是在 $n+1$ 这个位置（也就是 $firstpos(cur)$），这个位置一定大于 $firstpos(q)$，所以可令 $firstpos(t) = firstpos(q)$ .

### 求所有出现位置

和上例一样，维护 $firstpos$，并找到第一次出现的位置。

接下来考虑到一个点【在后缀链接树上的子树】中的所有叶子结点必然给出【这个点的 $endpos$ 集合】的所有单元素子集。所以直接遍历第一次出现位置的后缀链接子树，遇到叶节点就记录下来即可。

### 求最短不出现子串

直接DP就可以了，每个状态记录一下从当前点开始最少要走几步才可以遇到一个不存在某字符转移的状态。

### 求最长公共子串

现在有两个字符串 $S$ 和 $T$，求它们的最长公共子串。

首先，对 $T$ 建出后缀自动机，我们现在要做的是求出 $S$ 的每一个前缀在 $T$ 中出现的最长后缀。

那我们从 $1$ 号节点开始，每次尝试沿着转移边往前走，同时记录当前前缀的最长后缀 $now$ .

设当前走到的点为 $u$：

- 如果的确有这个转移，那就直接转移过去，令 $now = now + 1$ .
- 如果没有这个转移，就沿后缀链接向根走，同时令 $now = maxlen(fa(u))$ . 如果走了一步之后还是没有对应的转移，那就不停往上走，直到找到转移或者走到虚拟状态 $-1$ 为止。

答案就是上述过程中出现的 $now$ 的最大值。

### 最长公共子串Pro

给出 $m$ 个字符串 $S_k$，求他们的最长公共子串。

把所有 $S_k$ 拼接在一起，每两个串之间夹一个特殊字符 $D_k$ .

对形如 $S_1D_1S_2D_2\cdots S_mD_m$ 的新串建立后缀自动机。考虑某个串 $P$ 在所有 $S$ 里面都出现的充要条件是：对于每一个特殊字符 $D_k$，自动机里面都存在一个从【包含 $P$ 的状态】出发，经过字符为 $D_k$ 的边，不经过字符为 $D_1\cdots D_{k-1},D_{k+1}\cdots D_{m}$ 的边的一条路径。

直接DP求就可以了，然后对于每一合法状态的 $maxlen$ 取 $\max$ .

注意！这里的时间复杂度为 $O\left(m\sum_{i} len(S_i)\right)$ .

### 最长公共子串ProMax

给出 $m$ 个字符串 $S_k$ 组成的字典树，求他们的最长公共子串。

这个东西如果用刚刚的方法强行做的话可能会超时，我们需要**广义后缀自动机**。

## § 0.3 广义后缀自动机

所以现在有一棵字典树，我们要对这一棵字典树构建后缀自动机。

> 等等，对一棵字典树建立后缀自动机是什么意思？
> 
> 是指构建一个包含了这个字典树中所有字符串的所有子串的后缀自动机。

考虑一个字符串本质上就是一棵字典树退化成链的结果，所以我们理应只需要一些小的修改就可以建出广义SAM。

回顾构建一个普通后缀自动机的过程，本质上是选出自动机中已经存在的某个串 $s$，将 $s+c$ 的所有后缀自长至短插入后缀自动机中。

那么对于一棵字典树，我们按照其BFS序依次将字符插入，每次插入前将 $lst$ 置为当前节点的父节点，就可以构造出广义后缀自动机了。

等等！为什么是BFS序而不是DFS序？二者不是都可以保证这个性质吗？

这涉及到时间复杂度的分析。我们翻回到普通SAM的复杂度分析部分，重新看一下这几个操作的复杂度：

操作 $1,3$：并没有什么变化。

操作 $2$：可以把 $FinalPos(x)$ 定义式中的 $i$ 改为 $dep(i)$，时间复杂度分析依然不变。

操作 $4$：这个就值得玩味了，我们发现

## § 0.4 更多性质

注意出现位置相同的一定在一个等价类里，一个等价类里的一定出现位置相同。

或者对于某个终点而言，如果两个以此点为终点的

可以由此推出 CF700E 的关键结论

# Part 1 SA

虽然都说后缀自动机真包含后缀数组，但是显然后者处理某些问题更加好写。

所以这里简要介绍一下。

## § 1.1 线性求后缀数组

**后缀自动机的构建是** $O(n)$ **的，并且SA题目的瓶颈普遍不在于SA本身。**

~~不过求是可以求的，也就20KB吧~~

好，讲完了。

## § 1.2 普通方法求后缀数组

先说说后缀数组的基本定义：

把一个字符串 $S$ 的所有后缀拿出来，按照字典序排好序就是后缀数组了。

> 用后缀自动机确实也可以做到这一点，不过后缀自动机要带上一个 $|\Sigma|$ 的常数，在字符集较大的情况下会受到限制。所以我们要学习后缀数组。

看上去直接强行排序的话时间复杂度不会很友善，我们用倍增法排序。

首先，假设我们已经排列好了每一个字符开始，长度为 $len$ 的字串，接下来要对每一个字符开始，长度为 $2len$ 的字串排序。（不足的补零）

这很简单，对于一个子串 $[x,x+len-1]$ 而言，我们把他的排名当做第一关键字，把子串 $[x+len,x+len+len-1]$ 的排名当做第二关键字，对子串 $[x,x+2len-1]$ 排序。

> 注意，排序是否稳定无关紧要，即使每轮排序完毕后相同子串的顺序随机，也不会影响最终结果。因为在最后一次排序时必然不会有两子串（此时是后缀了）内容一致，所以对于每对可能相同的子串，总有一次倍增后两者不同。

注意到值域不超过序列长度，并且是双关键字排序，我们考虑用**基数排序**实现。

具体来说，先对第二关键字进行计数排序，再对第一关键字进行计数排序。

> 计数排序的过程是，对于每一个值 $x$ 计算它出现了几次（$cnt_x$），然后计算 $cnt_x$ 的前缀和 $sum$ . 最后倒序遍历原数组，把 $a[i]$ 放进 $sum_{a[i]}$ 这个位置，并令 $sum_{a[i]} = sum_{a[i]} - 1$ .

不过这样常数过大，考虑优化。

观察到第一轮计数排序的结果本质上是把所有 $sa[i] + len > n$ 的位置（第二关键字为空的位置）扔到了序列的最前面。剩下的按照原先顺序放入。

> $sa[i]$ 表示 $[x,x+len-1]$ 中排名第 $i$ 大的 $x$ .

这里有一个节省时间的小窍门：因为排序不需要稳定，所以无视掉之前排好的顺序，直接令 $TempSa(i) = n-len+i$ 即可。

> $TempSa$ 表示已经按照第二关键字排好的子串始点。

接下来一步中的“按照原序放入”的意思是按照第二关键字的顺序把子串始点放入 $TempSa$ 的后半部分中。

```cpp
int p = 0;
for(int i=n-len+1; i<=n; i++) tmpsa[++p] = i;
for(int i=1; i<=n; i++)
    if(sa[i]>len) tmpsa[++p] = sa[i] - w;
    //如果当前枚举到的sa[i]可以作为一个第二关键字的话，就把对应的始点塞进去
```

接下来进行第一关键字排序，这就比较简单了

```cpp
memset(cnt,0,sizeof(cnt));
for(int i=1; i<=n; i++) cnt[rk[tmpsa[i]]]++;
//这里的rk[x]表示的仍然是“始点为x，长度为len的字符串在其他等长字符串中的排名”，即上一轮的rk
for(int i=1; i<=m; i++) cnt[i] += cnt[i-1]; //这里的m是值域，在前一轮已计算完毕
for(int i=n; i>=1; i--) sa[cnt[rk[tmpsa[i]]]--] = tmpsa[i];
//这两行就是正常的计数排序
memcpy(tmprk+1,rk+1,sizeof(rk)); p=0;
for(int i=1; i<=n; i++)
{
    if(tmprk[sa[i]]==tmprk[sa[i-1]] && tmprk[sa[i]+len]==tmprk[sa[i-1]+len])
        rk[sa[i]] = p;
    else rk[sa[i]] = ++p;
}
//从小到大枚举已经排好序的子串，如果和上一个双关键字都相同的话排名不变。
m=p; //下一轮计数排序的值域。
```

当然这里有一些地方可以优化，比如说把 `rk[tmpsa[i]]` 单独存出来减少**擦车丢失**；比如最后确定新排名时用比较函数而不是直接比较，减少数组嵌套；再比如一旦我们发现某轮的最后存在 `p==n`，我们就可以直接退出循环。

```cpp
inline cmp(int x,int y,int w){return tmpsa[x] == tmpsa[y] && tmpsa[x+w]==tmpsa[y+w];}
//...
memset(cnt,0,sizeof(cnt));
for(int i=1; i<=n; i++) cnt[key1[i] = rk[tmpsa[i]]]++;

for(int i=1; i<=n; i++) cnt[i] += cnt[i-1];
for(int i=n; i>=1; i--) sa[cnt[key1[i]]--] = tmpsa[i];

memcpy(tmpsa+1,rk+1,sizeof(rk)); p=0; //节省空间
for(int i=1; i<=n; i++)
{
    if(cmp(sa[i],sa[i-1],len))
        rk[sa[i]] = p;
    else rk[sa[i]] = ++p;
}
m=p;
if(p==n) break;
```

总代码如下：

```cpp
inline cmp(int x,int y,int w){return tmpsa[x] == tmpsa[y] && tmpsa[x+w]==tmpsa[y+w];}
//...
m=26;
for(int i=1; i<=n; i++) cnt[rk[i] = str[i] - 'a' + 1]++;
for(int i=1; i<=m; i++) cnt[i] += cnt[i-1];
for(int i=n; i>=1; i--) sa[cnt[rk[i]]--] = i;
//对单个字符进行计数排序
for(int len=1; len<n; len<<=1)
{
    int p=0;
    for(int i=n-len+1; i<=n; i++) tmpsa[i] = ++p;
    for(int i=1; i<=n; i++)
        if(sa[i]>w) tmpsa[++p] = sa[i] - len;
    memset(cnt,0,sizeof(cnt));
    for(int i=1; i<=n; i++) cnt[key1[i] = rk[tmpsa[i]]]++;

    for(int i=1; i<=n; i++) cnt[i] += cnt[i-1];
    for(int i=n; i>=1; i--) sa[cnt[key1[i]]--] = tmpsa[i];

    memcpy(tmpsa+1,rk+1,sizeof(rk)); p=0;
    for(int i=1; i<=n; i++)
        rk[sa[i]] = cmp(sa[i],sa[i-1],len) ? p : ++p;
    m=p;
    if(p==n) break;
}
```

背诵并默写全文！

## § 1.3 height数组

定义 $height[i] = lcp(sa[i],sa[i-1])$，即排名为 $i$ 的后缀雨排名为 $i-1$ 后缀的最长公共前缀。

对于此数组有如下引理：

$$
height[rk[i]] \geq height[rk[i-1]] - 1
$$

> 即，**始点**为 $i$ 的后缀【与前一名后缀的lcp】至少是始点为 $i-1$ 的后缀【与前一名后缀的lcp】减一。

如何证明？

首先，$height[rk[i-1]]\leq 1$ 的情景是平凡的。

考虑画个图，我们假设排在 $[i-1,n]$ 前面的后缀为 $[p,n]$，并在图中把他们两个对齐，然后我们把 $i-1$ 也画上：

![string_img0.png](../_resources/string_img0.png)

由图可得，$[p+1,n]$ 这个串可以给 $[i,n]$ 兜底，如果有一个串，它与 $[i,n]$ 的lcp比图中画出的更短，由于字典序的性质它一定排不到二者中间，如果有一个lcp比这两者更长的，同理它一定会排在二者之间，贡献出更长的height给 $[i,n]$ .

> 为什么排在中间？首先根据 $p$ 的定义，浅绿串的字典序一定小于深绿串，这个时候如果来了个与 $[i,n]$ 这个串具有比蓝串更长lcp，且字典序比 $[i,n]$ 更小的新串 $N$，它与深绿串相同部分会更多，也就会排在浅绿串的后面。
> 
> 换句话说，两个后缀，二者的lcp越长，字典序就越接近。

由此引理可以快速求得height数组：

```cpp
for(int i=1,k=0; i<=n; i++)
{
    if(k>0) k--;
    while(s[i+k]==s[sa[rk[i]-1]+k]) k++;
    height[rk[i]] = k;
}
```

然后再利用这个求一下任意两后缀的lcp：

$$
lcp(sa[i],sa[j]) = \min_{k=i+1}^{j}\{height[k]\}
$$

感性理解：从i开始在排名维上一步步走到j，如果对于一个下标维上的位置（串上的位置），height始终大于他，那么他其实从i到j本质上就没变过，而如果height先是变短了又变长了，那么根据字典序的性质，即使变长了，变回来的也不是之前的东西了。

当然，更常用的形式是这个

$$
lcp(i,j) = \min_{k=rk[i]+1}^{rk[j]}\{height[k]\}
$$
