---
title: 2.3
updated: 2023-03-17 13:21:59Z
created: 2023-03-03 03:35:00Z
---

> 注释部分是 YHY 加上的

### CF1463F

任意一个长度为 $m=x+y$ 的解都能生成一个长度为 $n=tm+r$ 的解，直接循环构造。

然后就是任意一个最优解一定能转成长度为 $m$ 循环的解。

考虑构造按 $r,m-r,r,m-r,\cdots$ 这样分段，设 $delta_i$ 表示将所有与第 $i$ 段段编号奇偶性相同的段改成第 $i$ 段之后 $1$ 个数的改变量。若存在 $delta_x+delta_{x+1}\geq 0$ 则找到一个构造。

考虑反证，首先 $\sum delta_i=\sum delta_{2i}=\sum delta_{2i+1}=0$，根据假设任意两个相邻的和都是 $<0$ 的，然后按照总段数奇偶性分类讨论一下，总能推出第一段的 $delta>0$，这样推到最后即得出 $\sum delta>0$ 从而与条件矛盾。

所以就 $\mathcal{O}(2^{\max(x,y)}(x+y))$ 时间复杂度。

### CF919F

状态搜出来很少（搜可重集），然后拓扑排序能推出来就推，推不出来那就是在环里面平局的情况。

后面这个证明还是考虑归纳 /jy [都是有环有向图游戏和这个一样](https://atcoder.jp/contests/abc209/tasks/abc209_e)

### CF1342F

/jy 做过

https://www.luogu.com.cn/blog/dowhiletrue/solution-cf1342f

### HDU 6796

![image-20230203092351898](2.3.assets/image-20230203092351898.png)

暴力是 $f_{i,0/1,v_0,v_1,v_2,\cdots,v_9}$．

如果顶着上界，那么 $v$ 是定值。如果没有顶上界，那么每个数就都等价了，记录 $v$ 的可重集就行。

别 DP 了！另一个做法是，枚举一个前缀是顶上界的，然后后面就是任意选了，然后容斥 $2^{10}$ 钦定一下哪个子集是不合法的超了上界了，然后算个方案数就了。

> 这里的超上界指的是超出“数码个数”这个限制，而不是数值的上限。
>
> 这里的“随便选”意思就是后面的不贴上界

不容斥的话，生成函数推法（其实和容斥等价）大概就枚举那个是上界，然后剩下的就是几个等比数列乘起来，分母都是 $\frac{1}{1-x}$ 所以可以直接把分子乘起来然后每一个系数对最终系数的贡献是个组合数。

### GYM 102460 G

![image-20230203093527626](2.3.assets/image-20230203093527626.png)

$k$，以及得知哪些大小关系都是给定的。

对于每个有向图让它对应它的传递闭包，那么现在就是把传递闭包视作状态。然后大概需要搞个图 hash．

> $f[S]$ 为当前传递闭包为 $S$，至少还需要几次比较。

> 转移的方程如下：
> $$
f[S] = \min_{(u,v)\in E}\big\{max\{f[nxt(S,(u,v))],f[nxt(S,(v,u))]\}\big\}
> $$
> 外层的 $\min$ 体现最优策略，内层的 $\max$ 体现最坏情况。
>
> 即，策略的优劣取决于在这种情况下【我们选择询问哪一条边时最坏情况最小】，选择哪一条边是我们可以决定的，所以尽量选最坏情况小的。而内层的 $\max$ 就指的是这个“最坏情况”。

> 怎么判定一种传递闭包是否合法（能得到排名为 $k$ 的点）？枚举每一个点，然后判断剩下的点是否都和他关系已知，并且此点的排名为 $k$ .

由于 DAG 无环，所以可以采用这么一个 hash：$hash(i,j)$ 表示第 $i$ 个点走 $j$ 步的哈希值，其中 $hash(i,0)=deg_i$．那么 $hash(i,j)$ 就是把 $i$ 能走到的点 $i'$ 的 $hash(i',j-1)$ 给集合哈希起来。然后将每个 $i$ 的 $hash(i,j)$ 多项式哈希起来得到每个点的 hash 值，再把每个点的 hash 值集合哈希起来得到 DAG 的 hash 值。

> 集合哈希：把每个元素的哈希值排序之后多项式哈希就可以了。这种方法无关元素的顺序，只关注元素的本质不同。

> 注意，只有在有向无环图中，这种哈希才是正确的（有环的话路径可以有无穷长）

### CF1523F

只有做任务和激活门两种活动方式。

> 意思就是说，一次行动要么从一个已激活的传送点走到一个未激活的传送点，要么从一个已激活的传送点走到一个任务检查点。
>
> 当然也可以留在原地不动，不然这个东西会很麻烦。

dp 的思路就是，把状态需要知道哪些值讨论清楚。

这里状态就是激活传送门 $S$，当前位于哪个点 $i$，当前时间 $t$，以及完成任务数 $c$．

这四个值其中一个可以记到值域里面，然后就考虑咋优化定义域。

> 经验：dp 求的东西不一定要放到维护信息里面，也可以放在状态里面。

需要注意到，如果到了某个任务点，那么就已经知道时间了。

然后设 $f_{S,c}$ 当前激活了传送门集合是 $S$，完成 $c$ 个任务至少需要多少时间，然后它是位于任意一个传送门。（这里 dp 是优化掉了不用记录在哪个点）

$g_{S,i}$ 表示激活传送门集合 $S$，完成了第 $i$ 个任务时，最多能完成多少任务。（这里 dp 是优化掉了不用记录在哪个时间）

> 搞不明白为什么要记录两个平行的DP数组，非常神秘。
>
> 尝试梳理思路？首先可以按照时间顺序构建一条完整的动作序列，我们可以想出需要记录 $G$ 这个数组。
>
> 建筑顺序为时间顺序；一个阶段就是一次行动，因为如果考虑多次行动的话就类似旅行商问题了，一次行动对应一次转移；转移需要的接口是上次点亮了哪些传送点、上次完成的任务是哪个（不记录时间地点是因为，知道完成的任务编号就知道了时间和位置），记录的信息自然是钦定完成了 $i$ 时一共最多完成几个。
>
> 注意，信息和状态是可以互换以换取更快的复杂度的，从构建的角度来看 ，这相当于改变构建的顺序和接口。
> 
> 显然如果我们按照“一次走路”为粒度进行转移，我们要分两种情况讨论：
> 
> 1. 最后一步的终点是一个尚未点亮的传送点，对应的DP数组为 $f[S,c]$，表示在 $[1,i]$ 这些任务中激活了 $S$ 集合的传送点，并且完成了 $c$ 个任务，这种情况下需要的最短时间。
>    
>    为什么不把时间和任务交换位置，改为维度里面记录时间，状态里面记录数目呢？
>    
>    因为这样必须枚举时间，挑选次数最小的，会爆复杂度。（技巧：定义域、值域互换。在合法范围里面枚举时间，挑选总数最大的 => 枚举总数，挑选时间合法的）
> 2. 最后一步的终点是一个任务检查点，对应的DP数组为 $g[S,i]$，表示在 $[1,i]$ 这些任务重激活了 $S$ 集合的传送点，并且完成了第 $i$ 个任务情况下最多完成的任务书数目）
>
> 怎么更新呢？我们以第二种情况为主框架，转移 2 的同时附带着转移 1 。
> 
> 转移是容易导出的，推导过程这里省去了。
> $$
f[S,num] + dis(S,t) \to f[S+t,num] \\
g[S,i] =
> $$

### CF1103D

猪脑子/jy 可惜没有记下来

即使不能质因数分解，但是依然是考虑标准分解。

对于一个质数 $p$ 考虑如果它在某个数中出现过，那么就不用管它了。

那么现在需要关心的质数只有 $m=11$ 个。

假定现在是有 $m$ 个质因子出现了，然后还是考虑操作哪些会优一点，对于一个质数集合来说只会保留最便宜的 $m$ 个 $a$．跑一下爆搜大概是这里留下来最多是 ？？？

> 这道题的技巧在于通过适当的放缩减少状态空间，让暴力算法能够获得更优的复杂度。
> 
> 这也是优化状态压缩DP的一个重要思路，

> 我们发现消除一个质因子的时候，一定是选择原序列里面的一个数，并把这个数里面的**所有**这个质因子全部除掉，所以我们实际要关心的不是 $gcd$ 里面的质因子指数，而是每一个原数里面的质因子指数。因为如果这个质数在 $a_i$ 里面的指数比在 $gcd$ 里面大，我们仍然要按照大的消除，不然消不干净。
> 
> 假设所有数的 $gcd = \sum_{i=1}^{m}p_i^{c_i}$
> 
> 容易想出一个暴力的状态压缩：$f[i,S,j]$ 表示考虑了前 $i$ 个数，已经选择了 $j$ 个，消去的质因子组成集合 $S$ 的最小开销。
> 
> 然后我们只关心每一个数在 $gcd$ 的质因子集合意义下的指数，而对于若干个指数集合相同的数，我们只需要保留其中最便宜的 $m$ 个。
> 
> 这个时候我们的原序列从 $10^6$ 压缩到了 $1.2\times 10^4$（后者可以暴力搜索得出）。状态空间 $(10^6\times 2^{12}\times 12) \to (1.2\times 10^4 \times 2^{12}\times 12)$
> 
> 不过仍然能继续压缩空间，考虑对于一个质因子集合 $S$，能够消掉它并且可能被采用为答案的一部分的数最多只有 $m$ 个。所以转移的时候考虑当前的数在不在这一部分里就行。
>
> 具体转移的过程值得仔细说明：我们每个数对应上所有【它能够消去的质因子集合】组成的集合，这样我们就得到了一共 $12\times 2^{12}$ 个有效转移。然后把这些有效转移按照数的大小或者编号什么的排好序，分层转移即可（因为一个数最多只能被消一次）。
> 
> 状态空间 $(1.2\times 10^4 \times 2^{12}\times 12) \to 12^2\times 3^{12}$ . 足以通过本题。

### CF1034E

令 $a'_i=a_i4^{pop\_count(i)}$，然后将 $a'$ 和 $b'$ 或卷积起来的 $c'$，第 $i$ 项模 $4^{pop\_count(i)+1}$ 再除掉 $4^{pop\_count(i)}$ 就行。

实际上就是用 $4$ 作了个占位元，然后通过模掉 $4^{i+1}$ 来保证只有这一维的和 $\leq i$ 的才能产生贡献。

### CF1336E

/jy/xia/xia/dx/dx/dx/yiw/yun/dx

### Hihocoder 1230

![image-20230203141548177](2.3.assets/image-20230203141548177.png)

10s

因为序列长度是 $2n+1$，所以直接枚举 $x$ 不会算重（考虑固定前 $2n$ 个，然后从低往高确定 $x$）高！

枚举 $x$ 之后就异或卷积了。要求一个 $FWT^k(F)$ 这样子．

### CF1326F2

猪脑子非常强大。不过我没写过代码。

### Problem 13

![image-20230203144031290](2.3.assets/image-20230203144031290.png)

底层左右是对称的，所以两个位置 10 和 01 是等价的，那么状压的复杂度就变成了 $3^{13}*13$．核心思想就是找到等价类然后压状态。

### GYM 102798 E

有意思。考虑按顺序填入干碎人的那些操作。

那就 $f_{i,S}$ 表示现在操作了 $i$ 次，干碎了 $S$ 这个集合里面的人，没有打干碎人的那些操作还没有分配。

这个可以直接 $\mathcal{O}(2^nm^2n)$ dp，但其实可以一步一步转移，下一步如果没干碎一个人就直接乘个概率（这里其实也是为了后面计算填上不干碎人的操作作准备 就不用管概率的问题只考虑方案数就行了），如果干碎了再用组合数去分配方案。这里 $\mathcal{O}(2^nmn)$．

最后填上不干碎人的操作，实际上就是做个 EGF 的卷积。这里是 $\mathcal{O}(2^nm^2)$．	

### 栗题

给定一棵树，求这棵树最大的两个连通子图满足这两个子图同构且不交。$n\leq 40$．来源可能是 Topcoder 某题。

好像 NOI 2022 D2T1 啊/jy

先枚举断边，钦定其中一个根在端点上。考虑 $f_{i,j}$ 是一个根是 $i$ 另一个根是 $j$ 最大同构大小是啥，然后就发现转移是个最大权匹配跑费用流就行了。

### Topcoder 11779 SRM 533 Div1 Level3

把深度看成这个花费和。然后考虑如果选出了 $n$ 个编码，那么一定是小的匹配小的，大的匹配大的。所以对 $a$ 排序。

然后 $f_{i,j,v1,v2,v3}$ 表示当前深度为 $i$，还有 $j$ 个没分配。$dep=i$ 的有 $v1$ 个，$dep=i+1$ 的有 $v2$ 个，$dep=i+2$ 的有 $v3$ 个。

转移枚举 $v1$ 分配了 $x$ 个，然后剩下的 $(v1-x)$ 个节点都 expand 一下给下一个深度的 $v2,v3$ 加一加。

然后剪剪枝（$v1+v2\geq j$ 就直接全分配）大概就能过（确信）

### CS ACADEMY GCD on a Circle

![image-20230203154325983](2.3.assets/image-20230203154325983.png)

/fn 怎么老哥这么快就秒了。

先用线段树维护gcd，tow points 或者线段树上二分 $\mathcal{O}(n(\log n+\log v))$ 搞出来每个数向左延伸极长位置。

考虑枚举 1 那个块向左延伸到哪里，然后把这个后缀的 gcd 合并给 1．对于每个相同的后缀 gcd 只需要 $\mathcal{O}(n)$ 前缀和优化 dp 出来就行。

后缀 gcd 只有 $\mathcal{O}(\log v)$ 种（每次有个质因子的指数 -1）所以总复杂度就是一个 log．

### LOJ 3042

牌数：从小到大 $n$ 种，每种 4 张。

胡牌方式：1对子4面子 / 7对子

青蛙先摸了 13 张牌，然后剩下牌随机打乱。然后青蛙一张一张摸牌，直到手里的牌有一个子集能胡。求摸牌次数的期望。$5\leq n\leq 100$．

dp of dp

### 4 ARC 091 D

![image-20230203160828925](2.3.assets/image-20230203160828925.png)

下取整。

### CF 1779F

只有大小为偶数的子树有用。

那么问题就是能不能选出若干个不交的偶子树，使得其子树异或值是整棵树的异或值。

直接 dp 就 $\mathcal{O}(na^2)$？。。。
