# Part 0 生成函数的基本介绍

## 生成函数的由来

有的时候我们想表示两个序列的卷积

$$
C_x = \sum_{k=0}^{x} A_k \times B_{x-k}
$$

而这个时候我们注意到对于三个多项式 $P(x)\times Q(x) = T(x)$ 的**系数**有如下的定理：

$$
[x^n]T = \sum_{k=0}^{n} [x^k]P \times [x^{n-k}]Q
$$

> 此处 $[x^k]P$ 表示多项式 $P(x)$ 的第 $k$ 项的系数，下文记号含义同此。

正好就是卷积的形式！

而且我们知道多项式是一个性质很好的东西，可以~~肆意调教~~进行求导、求逆等灵活的变换。所以顺理成章地，我们可以把一个数列的各项分配给多项式的对应项，这样两个序列的**卷积**就可以方便地表达为两个多项式的**相乘**。

于是我们对于一个数列 $A_n$ 搞出了这么一个东西

$$
F(x) = A_0 + A_1 x + A_2 x^2 + A_3 x^3 +\cdots + A_n x^n
$$

这个函数就叫做数列 $A_n$ 的**生成函数**（又称母函数、OGF）。

当然，有的数列会有无穷项，如果继续随意变换的话会导致一些极限方面的问题。

不过生成函数里面的 $x$ 只是一个用来标记系数位置的**形式符号**，我们不会真的去代入求值，所以大可以假设生成函数**永远收敛**。

现在我们可以整理一下对生成函数的各种变换的意义了：

- 一个函数乘上 $x$ ：序列整体后移一位，空位补零
- 一个函数求导：序列整体前移一位并乘上原来的标号，余位删除
- 一个函数积分：序列整体后移一位并除以原来的标号，空位补零
- 两函数相加/减：两个序列对应项加/减
- 两函数相乘：两个序列进行卷积

## 生成函数的封闭形式

演算的时候，我们不希望直接处理生成函数的原式，因为这和直接处理序列本身没有区别。结合生成函数无条件收敛的性质，就有了这种把整个级数“压缩”起来的神奇变换：

假设有一个生成函数 $F(x) = \sum_{k=0}^{+\infty}x^{k}$

由于它有无穷项且收敛，所以下面的这个等式成立：

$$
F(x) = xF(x) + 1
$$

解方程，可以得到

$$
F(x) = \frac{1}{1-x}
$$

这个表达式叫做 $F(x)$ 的**封闭式**，它与前面的**展开式**是完全等价的。

> 可以证明，生成函数的展开式是其封闭式的麦克劳林展开

下面是一些常见生成函数的封闭式：

- $\sum_{i=0}^{+\infty} x^i = \frac{1}{1-x}$
- $\sum_{i=0}^{+\infty} (-1)^ix^i = \frac{1}{1+x}$
- $\sum_{i=0}^{+\infty} (ax)^{bi} = \frac{1}{1-ax^b}$

结合“生成函数相乘相当于序列卷积”的性质，我们可以用这些普通的函数表示大部分常见序列了。

当然，会有许多复杂的函数需要具体分析。

# Part 2 指数型生成函数

形如 $F(x) = \sum_{i=0}^{\infty}\frac{f_i}{i!}x^i$ 的函数叫做指数型生成函数（EGF）。

其中有具体组合意义的是 $f_i$ 这一项，不妨称其为“有效系数”，并把 $\frac{f_i}{i!}$ 称作“真实系数”。

EGF的相乘可以用来表示这种卷积：

$$
C_t = \sum_{x+y=t}\binom{t}{x}A_xB_y
$$

即

$$
C_t = \sum_{x+y=t}\frac{t!}{x!y!}A_xB_y
$$

这种卷积一般会出现在“组成组合对象的元素需要标号”的情况中。此类情况一般简称为“有标号”。

举个例子，若有红蓝两个序列，每个序列在长度为 $n$ 时有 $f_n,g_n$ 中合法构造方式。那么如果要求一个长度为 $n$ 的“红蓝相间的序列”有多少种方案，只需要把 $f,g$ 的EGF相乘，然后取 $x_n$ 项的有效系数即可。

> 当然还有另一种理解：
> 
> 用来相乘的两个小函数的阶乘系数代表“这些不用区分先后顺序，他们的顺序只有一种”，乘完了之后借出来的阶乘系数相当于“这些要区分先后顺序”。

换句话说，如果选择用EGF表示一种组合对象，那么这种组合对象必须含有与其“大小”，也就是下表数量相当的“元素”，并且“元素”有标号

“有标号集合”意为把组合对象放在一起而不拼接，这种集合的数量也就是“有多少种方式归并得到大组合对象”的意思。

为什么要除以那个阶乘因子去重？因为我们仅仅是把组合对象放在一起并重新标号，不区分组合对象的“颜色”。

假设某一个集合中有 $A,B,C,D$ 四个元素，那么在卷积的时候会有 $4!$ 中不同的路径把这四个元素依次卷起来，而这就意味着每一种方案被单独算重了 $4!$ 次。

> 注意！这也表明那个“单个元素的EGF”不能直接对自己做卷积，这样得到的结果也会因为算重而失去组合意义。

~~“元素之间无序”意味这【红色 $A$ 序列 $+$ 蓝色 $B$ 序列】和【红色 $B$ 序列 $+$ 蓝色 $A$ 序列】应当是同一种“放在一起的方式”（有标号集合）。~~ 这是错的

如果要对带标号的组合对象进行容斥，并且标号和容斥的限制有关（比如几个标号必须相邻），可以尝试通过把必须相邻的标号“捆成一个大对象”，并让这个大对象参与卷积，同时统计答案的时候也要算上大小 $\leq n$ 的部分。

当要求“某个元素必须在卷积后的序列末位”时，可以尝试把EGF的系数整体平移一位。

区分一下几个概念：

- OGF的乘方：一些不同颜色的组合对象拼接在一起
- EGF的乘方：一些不同颜色的组合对象拼接在一起，并且按照其度量大小重新标号，并保证原有顺序不变。