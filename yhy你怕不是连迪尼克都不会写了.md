---
title: yhy你怕不是连迪尼克都不会写了
updated: 2023-04-06 09:51:50Z
created: 2023-04-04 09:01:07Z
latitude: 36.65121600
longitude: 117.12000000
altitude: 0.0000
---

# Part 0 Ford-Fulkerson增广算法

| 算法    | 时间复杂度              |
|:-----:|:------------------:|
| EK    | $O(nm^2)$          |
| Dinic | $O(n^2m)$          |
| MPM   | $O(n^3)$           |
| ISAP  | $O(m\min\{F,nm\})$ |

> $F$ 为最大流的大小。

Ford-Fulkerson 增广算法包括 EK、Dinic、MPM、ISAP 四种算法，四者有一种共同的思想：每次尝试从一个劣流推导出一个更优的流，直到无法找到更优的流为止。

而为了找到这个更优的流，我们需要引入两个新的概念：**残量网络**和**增广路**。

先给出一个不完全的定义，我们把每条边的容量减去当前这个流在这条边上的流量，得到的图暂且叫做“剩余容量图”。

先从最平凡的情况谈起，如果流完目前的劣流之后，在剩余容量图上还有一整条由源点连向汇点的路径，那么直接把这条路径流满就可以了。

不过这样算法可能会走进死路，比如下图：

# Part 1 Push-Relabel预流推进算法

> 需要注意的一点是，预流推进算法和反悔贪心的关系并不是那么显然，如果要进一步学习费用流的话，此系列算法其实没什么用。

| 算法   | 时间复杂度            |
|:----:|:----------------:|
| 队列实现 | $O(n^2m)$        |
| HLPP | $O(n^2\sqrt{m})$ |

一般来说，我们手算网络流的时候，都是先假设靠近源点的边可以被流满，然后检验能不能把流进来的都流出去。由这种方法出发，就可以得到预流推进算法。

Push-Relabel 预流推进算法的基本思想为：一步步拼出最大流，先不管一个点流进去的能不能全部流出来，让某些节点可以溢出一些多余的流，在此基础上优先把靠近源点的边流满，接下来在后面的过程中伺机把超额的部分推送出去，最终让流合法。

> 这个“推送”的操作就是算法名称里面的 Push，具体意思为把尽量多的超额流顺着**残量网络**中的某条还有剩余容量的出边流出去。

首先，一个网络的最大流一定不可能大于 $st$ 的所有出边的容量的和，那么我们把起点 $st$ 的所有出边全部暴力流满，然后尝试把这些流推送出去。

如何推送？直接遍历图中超额的点，看看这个点的出边有没有剩余的容量可以用来推送就行了，不用管被推送到的点有没有超额，它早晚会被解决的。

如果最后所有点都没有办法继续推送了，删去剩下的超额流，我们就得到了一个最大流。

看上去非常美好，但这个程序根本没法运行：残量网络中是有反向边的，可能会有一些流被沿着两条反向边推来推去，使得算法无法结束。

为了解决这个问题，我们给所有的点设定一个“高度”，表征这个点有多确定已经不可能再被调整了（高度越高，越不可能被调整）。然后在推送的过程中，让流只能从一个点流向比它低一层的点（有点类似于 Dinic 里面的分层）。

而每次给一个点推送完毕之后如果还有剩余的超额流，我们不能浪费。于是我们抬高它的高度，使他恰好能够流向邻点中【高度最低的，还能流的】点，具体来说，是下面这样的：

$$
height(u) = \min_{(u,v)\in E,f(u,v)> 0} height(v) + 1
$$

这一操作称为 Relabel（重标记），也就是算法名字的后半部分。

> 如果推送完毕之后当前节点已经不剩下什么超额流了，那就不用变动当前节点的高度，因为以后可能还要流到这里来。
> 
> 抬高高度，意味着我们舍弃“这个点之后被流到的可能性”去换取“尽可能把当前的流流出去”。
> 
> 为什么这样是对的呢？严谨证明非常复杂，感性理解可以认为如果连现在的都流不出去，以后的进来也没啥意义。