---
title: 数学期望的笔记整理
updated: 2022-11-10 02:31:58Z
created: 2022-10-20 07:59:41Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

最后编辑于 2022.10.22 11:31

# Part 0 数学期望常用的公式

## 期望的定义

OI中用到的期望一般指的都是离散型的期望，它的定义如下：

$\xi$ 是一个随机变量， $S$ 是它的取值集合，定义 $\xi$ 的数学期望  $E(\xi)$ 为：

$$
E(\xi) = \sum_{x\in S}{P(\xi=x)\times x}
$$

因此期望具有**线性性**。换句话说，**期望的和等于和的期望、期望的倍率等于倍率的期望**。

> 血的教训：这两个式子**不要求** $X,Y$ 互相独立。

$$
\begin{gather*}
	E(kX) = kE(X) \\
	E(X+Y) = E(X) + E(Y)
\end{gather*}
$$

另外单独记忆一条性质，如果两个随机变量 $X,Y$ 是**互相独立**的，那么他们乘积的期望等于他们期望的乘积。

$$
\begin{gather*}
	E(XY) = E(X)\times E(Y)\\
	E(X^2) \neq E^2(X)
\end{gather*}
$$

# Part 1 期望类DP

## Luogu P1654 OSU!

### 题意

随机生成一个长度为 $n$ 的01序列，其中的每一个位置都有 $p_i$ 的概率为 `1`， $(1-p_i)$ 的概率为 `0` 。定义这个序列的分数为每一个极长连续 `1` 段的长度立方之和，求生成后的期望得分。

$p_i \in [0,1]$

$n\leq 10^5$

### 做法

我们考虑一下这一道题能不能通过递推的方法求出来。在一个序列末尾加入一个新元素后，显然可以按照新元素是否为 `1` 分成两类讨论，然后分别乘上这两种情况分别出现的概率，相加得到整体的期望。

> 具体来讲，分别假设（钦定）最后一个元素一定为 `1` /一定为 `0` ，求出这两种情况下的期望得分，再合并答案。

设 $f_i$ 表示只考虑前 $i$ 个元素的答案， $g_i$ 代表只考虑前 $i$ 个元素时序列从最后开始数，连续 `1` 段的**长度**（ $g_i$ 是一个随机变量！使用的时候需要加上期望算子！）。

> 注意！！期望的平方**不等于**平方的期望！
> 
> 所以，后缀连续段产生的贡献的期望不是 $E^2(len)$ ，而应该是 $E(len^2)$ ！
> 
> 为了避免这种很容易产生的错误，可以先写出**要求出期望的值**，不要把它化简，直接套上期望算子再化简。
> 
> 已这一道题为例，我们要求的是“后缀连续1段的得分”的期望值，那就直接写成 $E(score)$ ，再考虑 $score = g^3$

因为各个连续段产生的贡献的期望是可以从 $f_i$ 分离出来的（即线性性），我们可以通过减去再加回来的方式算出第一种情况的得分，得到下面的式子：

> 上面那一句话指的是 $f_i$ 可以写成 
> $$
 E\left(\sum_{k=1}^{m}{len_k^3}\right) = \sum_{k=1}^{m}{E(len_k^3)}$$
>
>（ $len_k$ 表示第 $k$ 个连续段的长度）
>
> 所以以后遇到复杂的期望式子可以先保留期望算符，方便推导

$$
f_i = \left(f_{i-1} - E(g_{i-1}^3) + E((g_{i-1}+1)^3)\right)\times p_i +f_{i-1}\times(1-p_i)
$$

稍加简化，我们有了：

$$
f_i = f_{i-1}+p_i\times \left( 3E(g_{i-1}^2) + 3E(g_{i-1}) +1 \right)
$$

仿照计算 $f$ 的方法，我们可以得到 $E(g_i)$ 和 $E(g_i^2)$ 的递推式子：

$$
\begin{gather*}
	E(g_i^2) = E((g_{i-1}+1)^2)\times p_i + 0\times (1-p_i)\\
	E(g_i) = E(g_{i-1}+1)\times p_i + 0\times (1-p_i)
\end{gather*}

$$

化简后得到这一组式子：

$$
\begin{gather*}
	f_i = f_{i-1}+\left( 3A_{i-1} + 3B_{i-1} +1 \right)\times p_i\\
	A_i = \left( A_{i-1} + 2B_{i-1} +1 \right)\times p_i\\
	B_i = \left( B_{i-1} +1 \right)\times p_i
\end{gather*}
$$

然后就可以快乐地做掉这一道题了。

### 总结

推导含有期望的式子的时候一定要记住期望的平方不是平方的期望

活用线性性，不要让数列的**下标**位置出现随机的变量，不然式子将无法推导

可以通过“分类—钦定—合并”的程序确定新增元素对答案的影响。

## Luogu P4550 收集邮票

###  题意

一共有 $n$ 种不同的邮票，每种有无穷多个。可以进行若干次随机选择（每一种物品被选到的概率均等），第 $k$ 次选择的费用为 $k$ .

求每种邮票都集齐时，所需要费用的期望。

$n\leq 10^4$

### 做法

先来转化问题，发现如果需要 $x$ 次把所有邮票种类集齐，那么所需要的费用为 $\frac{x(x+1)}{2}$ . 于是我们需要求出的就是这样的东西：

$$
\begin{align*}
	\text{ans}&=E\left(\frac{x(x+1)}{2}\right)\\
	&=\frac{1}{2}E\left(x^2+x\right)\\
	&=\frac{1}{2}\left(E(x^2)+E(x)\right)\\
\end{align*}

$$

仿照上一道题的的状态设计，我们令 $f_i$ 表示已经取到 $i$ 种邮票，**还要取几次才能集齐**的期望， $g_i$ 表示已经取到 $i$ 种邮票，还需要的次数平方的期望。

> 期望DP的状态经常设计为“已经完成了……还需要……的期望”，并且在转移的时候使用倒推的方法。
> 
> 这一点需要记住。
> 
> 你说刚刚那一道题没有倒推？那是因为序列正反算是对称的啦。

接下来开始推导状态转移方程吧！

我们假设目前经过了 $f_i$ 步，已经收集了 $i$ 种邮票，那么下一步我们会有两种可能：

- 取到已经收集到的某种邮票，概率为 $\frac{i}{n}$ . 因为我们“多取了一次”之后仍然需要 $f_i$ 次才能集齐剩下的邮票，所以期望步数应当看作 $f_i+1$ .
- 取到还没有收集到的某种邮票，概率为 $\frac{n-i}{n}$ . 显然这个时候“距离集齐还需要步数”的期望是 $f_{i+1}+1$ .

把以上两种情况乘上概率，得到下面的式子：

$$
f_i = \frac{i}{n}(f_i+1) + \frac{n-i}{n}(f_{i+1} +1)
$$

解一下方程，可以得到 $f_i$ 的递推式。

> **等等！这样不对吧！** 为什么 $f_i$ 在等式两边都出现了？
> 
> 的确，虽然这样推导看起来有失严谨，但它是正确的！在下面的“总结”部分会有几种（我自认为合理）的解释。

然后还要推导 $g_i$ 的转移方程，文字说明暂且先省略了，下面是计算过程（ $x_i$ 是一个**随机变量**，表示已经收集了 $i$ 种邮票之后距离集齐还需要多少步）：

$$
\begin{align*}
	g_i =& E(x_i^2)\\
	=&
    \frac{i}{n}E\big(\, (x_i+1)^2\, \big)+\frac{n-i}{n}E\big(\, (x_{i+1}+1)^2\, \big)\\
	=&
    \frac{i}{n}E\big(x_i^2+2x_i+1\big)+\frac{n-i}{n}E\big(x_{i+1}^2 + 2x_{i+1} + 1\big)\\
	=&
    \frac{i}{n}\big(E(x_i^2)+2E(x_i)+1\big)+\frac{n-i}{n}\big(E(x_{i+1}^2) + E(2x_{i+1}) + 1\big)\\
	=&
    \frac{i}{n}\big(g_i+2f_i+1\big)+\frac{n-i}{n}\big(g_{i+1} + f_{i+1} + 1\big)\\
\end{align*}
$$

> 可以看到推导 $g_i$ 的过程相当于一个“平方展开”的过程。

解完两个方程，我们就可以用递推做掉这一道题了。

### 总结

好，现在来处理一下刚刚的小问题——递推式的左右两边同时出现了 $f_i$ .

我现在对这个问题有三种理解方法：

1. 可以看成DP中的自环
	
我们知道DP有的时候会有环，这里就是其中的一种特殊情况。在其他的情况里，我们可能会看到 $f_{i-1},f_i,f_{i+1}$ 三者同时出现在一个方程里，根据常识我们要用高斯消元处理带有环的DP方程。

这里算是一种特殊情况（自环），一个状态“部分地”可以由它自己推导出来。因为只有一个方程，我们可以通过直接解方程的方法处理掉它。

2. 可以看成“偏差”

我们知道，在实际的取邮票过程中，当你已经集齐 $i$ 种邮票的时候，剩下还需要的步数不一定是 $f_i$ ,而**有一定的概率**与 $f_i$ 产生一定的“**偏差**”，我们写出的这个方程就是在特殊讨论这个“偏差”等于 $+1$ 的情况（比期望多取一次）。

假如说我们取了若干次，已经集齐了 $i$ 种邮票。那么，我们在下一步有 $\frac{i}{n}$ 的概率与期望值产生 $+1$ 的偏差（取到已经有的），有 $\frac{n-i}{n}$ 的概率不产生这一步偏差，与 $f_{i+1}$ 建立联系（取到还没有的）。

换句话说：“我们不知道期望值具体是多少，但是我们知道它**对应的随机变量**有 $\frac{i}{n}$ 的概率取比这个期望值多1的值，有 $\frac{n-i}{n}$ 的概率取一个与 $f_{i+1}$ 有关的值”

把产生与不产生偏差对应的表达式写出来，就得到了之前的递推式。

3. 可以根据期望的定义推导

对于任意一个“取了 $k$ 次，拿到了 $i$ 种邮票”的情景来说，紧紧跟在它后面的情景要么是“取了 $k+1$ 次，拿到了 $i$ 种邮票”，要么是“取了 $k+1$ 次，拿到了 $i+1$ 种邮票”，前者出现的概率是 $\frac{i}{n}$ 后者出现的概率是 $\frac{n-i}{n}$ .
	
我们定义随机变量 $\xi(k,i)$ 表示“已经取了 $k$ 次，收集了 $i$ 种，剩下还需要的步数”

$$
\xi(k,i) = \begin{cases}
\xi(k+1,i)+1&P=\frac{i}{n}\\
\xi(k+1,i+1)+1&P=\frac{n-i}{n}\end{cases}	
$$

根据数学期望的定义，写出下面的式子

$$
\begin{align*}
E\big(\,\xi(k,i)\,\big) &=
\sum_{x=0}^{+\infty}{\frac{i}{n}P\big(\xi(k+1,i)=x\big)\times (x+1)} +
\sum_{x=0}^{+\infty}{\frac{n-i}{n}P\big(\xi(k+1,i+1)=x\big)\times (x+1)}\\

&=
\frac{i}{n}\sum_{x=0}^{+\infty}{P\big(\xi(k+1,i)=x\big)\times (x+1)} +
\frac{n-i}{n}\sum_{x=0}^{+\infty}{P\big(\xi(k+1,i+1)=x\big)\times (x+1)}\\

&=
\frac{i}{n}E\big(\,\xi(k+1,i)+1\big)+\frac{n-i}{n}E\big(\,\xi(k+1,i+1)+1\big)\\

&=
\frac{i}{n}\Big(E\big(\,\xi(k+1,i)\,\big)+1\Big)+\frac{n-i}{n}\Big(E\big(\,\xi(k+1,i+1)\,\big)+1\Big)\\
\end{align*}
$$

现在，我们再从 $\xi(k,i)$ 的意义出发，我们知道无论你现在取了多少次，对你后来还需要的步数的期望都**没有影响**，所以对于任意的 $x,y$ 都有

$$
E\big(\,\xi(x,i)\,\big)=E\big(\,\xi(y,i)\,\big)
$$

所以，完全可以删去刚刚式子里面 $k$ 这一参数！

$$
E\big(\,\xi(i)\,\big)
=\frac{i}{n}\Big(E\big(\,\xi(i)\,\big)+1\Big)+\frac{n-i}{n}\Big(E\big(\,\xi(i+1)\,\big)+1\Big)
$$

> 这一步是一次换元，大可不必强行理解这样做的概率意义

最后，就有了我们熟悉的

$$
f_i = \frac{i}{n}(f_i+1) + \frac{n-i}{n}(f_{i+1} +1)
$$

## Luogu P1850 [NOIP 2016] 换教室

### 题意

给定一张有 $V$ 个点和 $E$ 条带权边的无向图，和两个长度为 $n$ 的点的序列 $a,b$ .

接下来对 $a$ 中的**至多** $m$ 个元素进行操作，对于第 $i$ 个元素的操作有 $p_i$ 的概率使 $a_i\leftarrow b_i$ .

进行完这些操作之后，有一个人从 $a_1$ 开始，依次沿着最短路径走到 $a$ 序列中的下一个点。要求找到一种操作方案使得最后人所走的路径的长度的期望最小，输出这个最小期望值。

$V\leq 300$

$E\leq 9\times 10^4$

$n,m \leq 2000$

### 做法

首先可以观察到图里面的点数量只有 $300$ 个，可以用 Floyd 算法求出任意两点之间的最短路，方便后面的计算。

然后我们注意到，前面走过的路径无论是怎么样的，都不会影响到我们后面所走的路径。所以我们考虑用 DP 来解决这个问题。

设计状态 $f[i,j,1/0]$ 表示在【已经走完了 $i$ 个点对】【在这期间用掉了 $j$ 次操作机会】【最后一次有/没有进行操作】的情况下已经走完路径的期望长度。

由于期望的线性性不要求两个随机变量相互独立，即使一个点对是否操作的决策会**同时**影响前后两段路径的期望长度，我们也可以把他们两个分开来处理。

分类讨论一下，状态转移方程还是比较容易写出的

$$
\begin{cases}
	f[i,j,0] =\min \begin{cases}
		f[i-1,j,0] + \text{dist}(a_{i-1},a_i) & 上一个点不选\\ ~\\
		\begin{align*}f[i-1,j,1] &+
			p_{i-1}\times \text{dist}(b_{i-1},a_i) \\
			&+(1-p_{i-1})\times \text{dist}(a_{i-1},a_i)
		\end{align*} & 上一个点选了
	\end{cases}\\~\\
	f[i,j,1] =\min \begin{cases}
		\begin{align*}
			f[i-1,j,0] & +p_{i}    \times \text{dist}(a_{i-1},b_i) \\
			           & +(1-p_{i})\times \text{dist}(a_{i-1},a_i)
		\end{align*} & 上一个点不选 \\ ~ \\
		\begin{align*}
			f[i-1,j,1] & +p_{i-1}  \times p_{i}    &\times \text{dist}(b_{i-1},b_i) \\
			           & +p_{i-1}  \times (1-p_{i})&\times \text{dist}(b_{i-1},a_i) \\
			           & +(1-p_{i-1})  \times p_{i}    &\times \text{dist}(a_{i-1},b_i) \\
			           & +(1-p_{i-1})\times(1-p_{i})&\times \text{dist}(a_{i-1},a_i) \\
		\end{align*} & 上一个点选了\\
	\end{cases}
\end{cases}
$$


~~真的非常简单呢~~

时间复杂度是 $\mathcal{O}(n^2)$ 的，足以通过此题。


### 总结

期望类的 DP 设计状态时，可以钦定最后一次决策，这样可以减少许多不必要的分类讨论。



# Part 2 计数&贡献类的期望问题

我们需要了解这样一个基本的事实：

“集合 $S$ 中满足条件 $p(x)$ 的元素的数目 $n$ 的期望 $E(n)$ ” 等价于 “集合 $S$ 中每个元素 $x$ 满足条件 $p(x)$ 的概率之和”.

> 证明：
> 
> 其实就是期望的线性性在计数类问题上的具体体现
> $$
  E\left(\sum_{x\in S}{\big[p(x)\big]}\right) = \sum_{x\in S}{E([p(x)])} = \sum_{x\in S}{P\big(p(x)=\text{True}\big)}$$
> 


并且我们还知道，“长度”、“次数”这些题目可能要求统计的变量本质就是“计数”，所以我们可以用转化问题的方法解决这一类期望问题。

## CodeForces 280C Game on Tree

## 题意

给定一棵 $n$ 个节点的有根树，每次从存在的节点中随机选取一个节点，删除它和它的子树。求所有节点被删除完毕所需要的操作次数的数学期望。

$n\leq 10^5$

## 做法

按照上面的思路转化问题，把每次被选中的点写成一个序列（不妨称其为“操作序列”），答案就是操作序列的长度的数学期望。

而根据刚刚推导得出的结论，【序列的长度的数学期望】等价于【每一个可能出现在序列中的元素（也就是原树上的每一个节点）在序列中出现的概率之和】。我们就把这一道题转化为了计数问题。

接下来考虑如何计算出原树上的节点在最终的操作序列里出现的概率。

稍稍改变一下每一次随机取点的方法，不再把整个子树和被选中的点删除，而仅仅是把它们打上一个标记。相应地，每一次如果取到了带有标记的节点就再取一次，直到取到一个没有标记的节点为止。

因为在这种新的取法里面，我们对于任何一个点都没有“偏好”，所有操作都是均匀随机的，所以在**仅仅在被选到的概率方面**，它和原来的方法是等价的。

这种情形下，一个点出现在操作序列里的**充分必要条件**是【选到他之前，由他到根节点的路径中没有任何一个点被选中】。

按照这个条件重新思考，由于我们的操作是**均匀随机**的，很显然，根链的节点们中，每一个点 “成为首个被选择的点” 的机会是**均等的**（假如说一次选取选到了根链外面的点，对于里面的点没有任何影响）。因此，**原树中**任意一个节点出现在最终操作序列里的概率是 $\frac{1}{dep(x)}$ .

于是乎，答案就是

$$
\sum_{x=1}^n{\frac{1}{\text{dep}(x)}}
$$

~~码量和思维严重不匹配~~

### 总结

可以把“次数”通过线性性进行转化，方便统计期望。