# Part 0 常用哈希方法

哈希，即寻找一个映射，满足当原对象的某个特征不同，等价于映射到的值不同。

## 多项式哈希

典型的例子是字符串 hash，我们有一个序列

$$
a_1\cdots a_n
$$

把它视为一个多项式

$$
f(x) = a_1x^{1}+\cdots +a_nx^{n}
$$

然后随机一个 $x$ 带入求值即可。

一般为了防止被卡，会选取 $2\sim 4$ 个模数，防止碰撞。

> 哈希值不同当且仅当序列不同。

另外一种类似的方法是，给序列的每一个下标对应一个随机权值，然后和序列中对应位置的值相乘，求和即可。

## 集合哈希

如果可以定义集合间元素的大小顺序关系，一种方法就是将元素排序之后进行上述多项式哈希。

> 哈希值不同当且仅当集合中元素不同。

另外一种方法来自 CSP2022 T3，给所有可能出现在哈希过程中的集合元素赋一个随机权值，然后集合的哈希值就是所有元素的哈希值的异或和。

这种方法适用于需要从集合中去除/加入元素，并实时维护哈希值，注意只适用于单重集合。

## 有根树哈希

> 哈希值不同当且仅当：两棵树抹去编号，保留祖先关系后，按照同样的规则查新编号，得到的新树完全一致。重新编号时不区分子节点的顺序。

定义 $H(u)$ 表示以 $u$ 结点为根的子树的哈希值。

$$
H(u) = C + \sum_{v\in Son(u)} f(H(v))
$$

其中 $C$ 是一个随机的常数。$f$ 是一个随机映射，一般使用 xor shift，如下：

```cpp
ULL XorShift(ULL x)
{
	x ^= A;
	x ^= x<<13; x ^= x>>7; x ^= x<<17;
	x ^= B;
	return x;
}
```

$A,B$ 都是随机的常数。

## 无根树哈希

> 哈希值不同当且仅当：存在一种指定祖先后代关系、子树顺序的方式，使两棵树完全重合。

一个方法是先搜一遍找到这棵树的重心，以他为根进行有根树哈希，如果有两个重心，取哈希值较大的。
