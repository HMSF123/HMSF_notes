---
title: 错题集
updated: 2023-03-30 06:59:08Z
created: 2022-10-21 11:27:58Z
latitude: 35.10467400
longitude: 118.35641400
altitude: 0.0000
---

# 一定要看看需不需要开 `long long` ！！！
# 就算数据范围很小，乘方之后也可能会溢出 `int`
另外，`long_long_max = 9223372036854775807` .

# 分析状态空间大小的时候，一定**不要直接相乘**，必须仔细推导

# Powershell中逗号是一个关键字，开栈的时候应该加上单引号，写成 `'-Wl,--stack=1677721600'`

# 经典错误

- 数组开的不够，但是评测结果是WA
	- 这种情况一般是出现在为了防止负数下标给数组加了一个整体偏移，但是没有把空间开为二倍

# 结构体
- 写构造函数的时候一定要确保函数中参数的类型和结构体中的类型相同（不要结构体里用了个 `double` ，但传参的时候传了个 `int` .
- 还是要注意开 `long long` .

# 二分
- 如果每次迭代时令 $l=mid+1,r=mid$ （左侧紧缩），这种二分取 $mid$ 时应使用语句 `int mid = (l+r)>>1;` .
- 如果每次迭代时令 $l=mid,r=mid-1$ （右侧紧缩），取 $mid$ 时应使用语句 `int mid = (l+r+1)>>1;` .

以上的两种二分方法的循环条件都是 `l<r` .（在 `r==l` 时结束循环） 

# 查找连续段

```cpp
for(int i=1; i<=n; i++)
{
	int now = a[i];
	for(; a[i]==now; i++)
	{
		/*这里是你需要对每一个连续段干的事情*/
	}
	i--;
}
```
这种方法可以访问到每一个连续段。

# 点分治

- 每次找到当前树的重心**后**记得打上 `vis` 的标记
	- 找到重心之后令 `now = rt;` ，然后再执行 `vis[now] = true;` .
- `void getCenter(int u,int lst)` 这个函数里面记得把儿子遍历两次：**第一次**求出 `mxc[u]` ；**第二次**求出子树中节点的 `mxc` .
	- 因为必须把当前点作为根节点时最大的子树大小求出来算法才能继续进行，否则之后的比较都是无意义的（第一个搜到的点的 `mxc` 是 `0` ）
- 记得特殊处理链的一端就是当前的根节点（ `now` ） 的情况

# 树形DP

- 对于一棵无根树而言，若需要判断一个点是否为叶节点，根本不需要计算节点子树的大小，只需要看看节点的度数是否为 $1$ 就可以了。

# 状态压缩DP

- 记得用刷表法转移，可以显著减少代码长度
- 预处理的时候把所有比特位中只有一个 $1$ 的处理完
- 在纸上写一下位运算的过程，防止出错

# 无旋Treap

要注意的点非常多，一不小心就会WA

- 如果要维护 `me.faz` 信息，在每一层的分裂/合并函数里面，要**先把当前这一个/两个节点的 `faz` 清零**，并在递归完毕之后把当前节点的**两个孩子**的 `faz` 统一赋值为 `x` .

- 按照排名分裂、查询排名的时候千万不要忘记加上节点本身的大小（ `me.rep` ）

- 而且查询某个值在序列里的位置时，判断这个点是左儿子还是右儿子的时候，**一定要判断**这个点是不是根

- 执行 `extract` 操作的时候，注意有可能我们要找的排名是 `0` 或者 `n+1` ，所以一定不要忘了判断 `x==0` 的情况（出现了的话直接令 `l=mid=r=0;` 就可以了）

- `extract` 找到一个节点的时候记得让它的 `siz=1;`

# CDQ分治

- CDQ 分治的时候一定要注意，如果要把区间通过扫描指针的方式分为两半，那么一定要记住指针从 $L-1$ 这个位置开始，不然无法处理左区间为空的情况

# 向上取整

- $a=\left\lceil\frac{b}{n}\right\rceil$ 可以写为 `a = (b+n-1)/n`

# LCT

要注意的点非常非常多，一不小心就会WA

- 首先，在 `Link` 的时候，如果维护了大小信息，必须要把两个点都先 `MakeRoot`，不然被链接点的大小改变无法及时上传到父节点，会引起问题。
- `MakeRoot` 最好同时把当前节点变成原树根和辅树根，会省去不少麻烦。
- `Rotate` 的时候把三个点都更新一下。
- `Cut` 的时候记得像这样判断合法：`if(p!=x||fa[y]!=x||ch[y][0]) return;`，其中 `p=Find(y)`，这里一定不能出错。
- 洛谷模板数据弱的可以，有一些致命错误会被放过去。
- 牢记：
	- `Splay` 操作不会影响原树的结构，但是会影响辅树的结构。
	- 只有区间翻转操作、`Link` 和 `Cut` 操作会改变原树的结构。
	- 将 $x,y$ 两个点分别 `Access` 一次之后，第二次的返回值是两点的 LCA 位置。
	- 多想想要不要更新信息、要不要把节点转到根。
	- **维护的siz[x]并不是（？）原树上x节点的子树大小**
- 虚边在原树上是链接两条树链的边，在辅树森林中，这条虚边的父节点必须是原树中对应的父节点，但是其子节点可以是其所连接的下方的那条树链中的任意节点。（树链可以从中间开始挂，但是必须挂对位置）

# 凸包

- 线切凸包的时候初始化 `l=1,r=n;`，循环时直接判断切点前面的线段的斜率是否比直线的斜率小（因为如果凸包内只有一个点，根本不会循环；如果有多个点，不可能访问到 $1$ 号节点），调整范围的时候左侧紧缩（一旦前面的斜率比切线小，那么这个点一定不合法，否则可能合法）。 

# 莫队

- 带修改莫队一定要判断当前操作在不在当前区间里面，并且一定要记住，扩展时间的时候先让 `T++`，再进行剩下的所有事情，缩小时间的时候，先做完所有事情再让 `T--`。
- “时间”这个变量可以改为“前面进行的修改操作数目”，实现起来更加方便。

# 卢卡斯定理

- 记住，你实现的 `comb(N,R,mod)` 函数中，因为传入的参数是 `N%mod,R%mod`，所以可能会有 `N%mod < R%mod` 的情况出现，这种情境下应当返回 `0` 。

# SAM

- 分裂状态的时候，新的状态 $t$ 是稍短的那一个，并且记住要重新定义的量有 `maxlen[t]`，`link[t]`，`link[q]`，`link[cur]` .
- SAM 上线段树合并维护终点集合时，对于每一个 $cur$ 新建一个线段树，然后合并即可。合并的时候，如果一个点上本来没有线段树（`ver[u]==0`），那么可以新建一个版本 $0$ 的线段树，这样直接强行合并也没有问题。
	- 此外要记住一点，合并的时候直接暴力新建所有节点即可，空间复杂度是正确的。