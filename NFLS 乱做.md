# Day2 T2

**牛了个大逼题**

设计状态 $f[i,j]$ 表示考虑了 $i$ 个物品，$j$ 介于花掉的钱和积分之间时，能拿到的最小声望。

转移直接

$$
f[i,j] = \min_{k=j-B_i}^{j-A_i}\{f[i-1,k] + C_i\,,f[i-1][j]\}
$$

太他妈牛逼了

思路大概是看到有两维的限制是相同的，那么尝试用“小一号”的原问题转移到原问题，结果大获全胜。

或者说，我们注意到只需要保证两个维度与同一个指标的“大小关系”，并且每次增加新的值不会影响两个指标的相对大小，那么就可以用一个中间值记录，而不用开两维。

# Day2 T3

**题意**：按照省选成绩从高到低给出 $n$ 位选手是否进入省队，求有多少种把选手分配给 $m$ 个学校的方法。选省队的时候按照 $lim = \lfloor\frac{a}{k}\rfloor$ 的比例卡校线。（即每个学校的省队人数不能严格大于这个值）

**做法**：设 $A$ 为省队守门员的排名，显而易见的，最后 $n-A$ 个选手归属哪个学校都可以，所以最后统一乘上一个 $m^{n-A}$ 的系数即可。

首先考虑如果没有卡校线的情况发生，那就相当于把 $a$ 个不同的球放进 $m$ 个有区别的箱子里面，并且箱子里面不能有超过 $lim$ 个球。

设计 $f[i,j]$ 表示把 $i$ 个选手按照上述要求分进 $j$ 座学校的方案数。可以按照如下的方式转移：

$$
f[i,j] = j\times f[i-1,j] - j\times f[i-lim-1,j-1]\times\binom{i-1}{lim}
$$

> 即，强制接上一个新选手，再减去所有【某学校的人数超过 $lim$】的情况。

> 根据题意可得，当 $i>lim*j$ 时DP值可以直接赋值为 $0$ .

看起来时间复杂度是 $O(nm)$ 的，不过其实不要紧，用不到那么多的状态。

然后考虑卡校线的情况。一个可能的计数思路是，找到一个“断点”把序列分成两个部分，让第二个部分成为刚刚能够处理出的情况。

容易发现，只要把所有被卡了校线的**学校**拎出来，剩下的东西就和刚才一样了。

枚举 $i$ 表示有多少所学校被卡了校线，$G(i)$ 表示此时有多少种方案把被卡了校线**学校**的选手放进排名里面。

> 为什么不是只考虑那些被卡出省队的选手，因为他们进了省队的同校必须位于他们之前，并且恰好有 $lim$ 个。

那么答案就是

$$
m^{n-A}\sum_{i=0}^{K}\binom{m}{i}G(i)\times f[a-i\times lim,m-i]
$$

> $K=\left\lfloor\dfrac{a}{\lfloor\frac{a}{k}\rfloor}\right\rfloor$

这里需要用到多少个 $f$？

首先，根据 $f$ 的转移式的第一项，$f[0\sim a-i\times lim,m-i]$ 这 $O(nk)$ 个状态是一定要用到的。

注意到，计算 $f[x,m-i]$ 的第二项所需要的 $f[x-lim-1,m-i-1]$ 正好也是一个被用到的值。同时，递归到底时用到的 $f[0\sim a-K\times lim,m-K]$ 暴力计算的复杂度为 $O(mK)$。

刨去可以特判的 $0$，总的时间复杂度是 $O(nK)$，完全不成问题。

考虑如何计算 $G(i)$ . 设计状态 $g[i,j]$ 表示仅考虑了前 $i$ 个被卡了校线的选手时的 $G(j)$ .

$$
g[i,j] = 
j\times g[i-1,j] +
j\times g[i-1,j-1]\times \binom{c_i-(j-1)lim}{lim}
$$

其中 $c_i=\sum_{k=1}^{i} a_k$，也就是前面有几个人进了省队。

显然这部分的复杂度也是 $O(nK)$ .

齐活儿

# Day2 T4



# Day3 总结

今天早上精神状态不太好，想了2h才想到T1的做法应该是把序列按照上升子串划分为 $n/k+1$ 段，然后再从小往大放置。

T2没有多少时间，所以没有做出来，非常遗憾。

# Day3 T3

**题意**：在一棵树上随机游走（每次在与该点相邻的、合法的点中等概率选一个），每个点经过两次后会被割掉，每一个点有一个点权。求最终到达的点的点权的期望。

**做法**：首先把点权差分成边权，问题从单点变成路径。注意到每条边最多经过三次，并且一条边只有被经过奇数次的时候才会对答案产生贡献。那么按照这个设计状态DP。

尝试令 $f[u,0/1/2]$ 分别表示

- 仅考虑 $u$ 的子树及其父亲，强制 $u$ 的父亲边被从上到下经过了一次的概率期望得分
- 强制 $u$ 的父亲边被经过了两次的期望得分，条件同上
- 强制 $u$ 的父亲边被经过了三次的期望得分，条件同上

尝试写出转移方程时发现，第二个状态中，可能来到 $u$ 之后立即回去，也有可能绕了一圈再回去，这两者是有区别的：前者可能还会再次来到 $u$ 这个点，后者会把 $u$ 这个点去掉。

更具体一点，当 $v,w$ 都是 $u$ 的孩子时，$u\to v\to u \to w$ 这条路径和 $u\to v\to subtree(v)\to v\to u\to w$ 这条路径中，走出最后一步 $u\to w$ 的概率是不同的，前者为 $\frac{1}{2}$，后者为 $1$ . 所以我们要把这两种情况分散在两种状态里面。

同时，第一种状态也要划分成两个子类，因为如果在往下走之前，父亲已经被经过一次，那么计算概率是会有一点差别。

$f[u,0/1/2/3/4]$ 表示：

- 仅考虑 $u$ 的子树及其父亲，$u$ 的父亲边被从上到下经过了一次的期望得分
- 仅考虑 $u$ 的子树及其父亲，$u$ 的父亲边被从上到下经过了一次的期望得分（但是父亲已经被走过一遍）
- $u$ 的父亲边被经过了两次，$u$ 的子树没有被经过的期望得分，条件同上
- $u$ 的父亲边被经过了两次，$u$ 的子树被经过的期望得分，条件同上
- $u$ 的父亲边被经过了三次的期望得分，条件同上

转移方程为：

$$
\begin{align*}
&f[u,0] = W_{fa\to u} + \sum
\begin{dcases}
\frac{1}{D_u^2}\sum_{v\in Son(u)} f[v,4]\\
\frac{1}{D_u^2-D_u}\sum_{\substack{v,w\in Son(u)\\ v\neq w}} f[v,3]+f[w,1]\\
\frac{1}{D_u^2}\sum_{\substack{v,w\in Son(u)\\ v\neq w}} f[v,2]+f[w,1]\\
\frac{1}{D_u}\sum_{v\in Son(u)} f[v,0]
\end{dcases} \\
&f[u,1] = W_{fa\to u} + \sum
\begin{dcases}
\frac{1}{S_u^2}\sum_{v\in Son(u)} f[v,4]\\
\frac{1}{S_u^2-S_u}\sum_{\substack{v,w\in Son(u)\\ v\neq w}} f[v,3]+f[w,1]\\
\frac{1}{S_u^2}\sum_{\substack{v,w\in Son(u)\\ v\neq w}} f[v,2]+f[w,1]\\
\frac{1}{S_u}\sum_{v\in Son(u)} f[v,1]
\end{dcases} \\
&f[u,2] = 0 \\
&f[u,3] = \frac{1}{D^2_u - D_u}\sum_{v\in Son(u)} f[v,3] \\
&f[u,4] = W_{fa\to u}
\end{align*}
$$

> $D_x$ 表示 $x$ 的度数，$S_x$ 表示 $x$ 的孩子数量，$W_{a\to b}$ 表示边权。统计答案时给 $1$ 无中生爹 $n+1$，然后答案为 $f[n+1,1]$ .

可以看出真正有用的只有两个状态（？？？？）

# Day3 T4

观察到性质：最多只有一个物品没有被选满次数。

那么最暴力的想法就是枚举这个物品，放进DP数组里面，然后把剩下的东西各自绑定成一个整体，然后做 $01$ 背包。这样省去了合并背包的复杂度，总时间为 $O(nm^2)$ .

发现时间浪费在了进行重复的合并上，有些时候我们不用进行完整个合并过程就可以断定一个选择比另一个更劣。

如何断定？考虑分治。可以把【至多有一个物品没选满】的背包拆成【至多有一个物品没选满】的背包和一个【所有物品都选满】的背包。

那么直接对物品分治下去即可。每轮分治返回【至多有一个物品没选满】的背包，合并的时候把右边的物品捆绑，扔进左边；左边的物品各自捆绑，扔进右边。最后每个位置取 $\min$ .

> 启发：可以通过把问题拆成规模较小的子问题、规模较小且易解决的另一个问题的方式 进行分治。

# Day4 总结

今天非常失败！

首先T1浪费的时间有点多，至少比理想情况多了30min

然后T2没有重视树随机生成的性质，所以没有得到正解

T3如果早点开始做的话是可以做出来的，但是在T2上浪费了绝大多数的时间。

# Day4 T2

**Tag**：随机保证，暴力

耻辱性的失败！以后不能继续头铁了。

重要性质：随机生成的树，无论以哪个点为树根，期望深度为 $O(\sqrt{n})$ .

另一个重要性质：如果图中某一个点的最短路发生改变，从它开始暴力松弛即可更新所有的新最短路。

那么合在一起就有了这一题的做法了。

# Day 4 T3

**Tag**：枚举，DS

首先考虑旋转的不是 $A$ 而是 $B$ .

在外层枚举 $B$ 最终完成时转到哪一个位置。这时我们就可以确定有哪些位置是要被更改的。所以我们的目标就是在最小的旋转次数下，让每一个需要修改的位置被至少“扫过”一次。

注意到为了保证最优性，$B$ 一定是先左移一段，再右移一段（或者反过来），最后按照最短路来到 $p$ .

具体要位移多少呢？对于每一个需要修改的位置，求出 $B$ 在初始位置时，其左边的第一个 $B$ 中 $1$，记作 $r_i$；同理求出右边的第一个 $1$，记作 $l_i$ .

那么问题转化成，对于每一对 $L_i,r_i$，选择其中一个，令 $L=\max l_i,R = \max r_i$（仅限被选中的），最终的答案就是 $\min\{ 2L+R+dist(R,p),2R+L+dist(L,p) \}$ .

把点对放在二维平面，发现 $L$ 只取决于不被矩形 $r\in[0,R],l\in(-\infty,+\infty)$ "覆盖"到的点，于是可以枚举 $R$，然后根据 $R$ 计算出 $L$，最后取最小的作为备用答案。

记得加上取反所需要的操作数目。

# Day 4 T4

技巧：“一一对应”，并且每个甲集合元素可以选择的乙集合元素数量相同，那么这样的匹配问题可以尝试建立二分图。

而“二选一”的“一一对应”模型，可以考虑把建立二分图改为连边，“二选一”变成“边定向”。

# Day 6

这次主要是太懈怠了。

T1大概花了30min

T2问题很大，完全没有深入去想，一直在想怎么打表。应该往通过已知信息得出新结果的方向去想的。可以考虑对这个结构进行递推。

T3yx想了但是我没有时间看题。想必是因为前两题浪费了太多时间，然后 T3 就算让我来，感觉也想不出分治的策略。如果要想到的话应该可以类比

# Day 6 T1

没啥难度，考虑先枚举既约分母是什么。然后 $O(\sqrt{n})$ 数论分块即可。

# Day 6 T2

没啥难度，考虑如何根据已经有的结果计算出新的合法解。发现 $10^k$ 的二进制表示下最后一定有 $k$ 个 $0$ . 那么在非法数字的十进制表示前面外加一个 $0$ 或者 $1$ 都无法让它变得合法。

所以直接暴力BFS即可，复杂度是有保障的。

# Day 6 T3

考虑进行分治，每次随机选一条边，处理询问点在这条边两侧的所有问题。

维护数据结构的话可以用类似边分治的方法，每次暴力把不能走的那一边全部标为 `vis` .

# Day6 T4

