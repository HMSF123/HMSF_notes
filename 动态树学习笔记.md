# Part 0 Link-Cut Tree

**Link-Cat Tree**，连猫树。

## 模板

我们希望维护一棵动态的树，支持加边、断边，并维护连通性的信息。

定义**实链剖分**：随便剖分。

~~其实没错~~

我们随便把一棵树剖成树链，保证里面的每一条链都是从某一个节点连接到一个叶子，并保证所有链给出树的点集的一个划分，这就是一个合法的实链剖分方案了。

出现在这些链里面的边称作这个方案中的**实边**，不出现在这些链里面的边称作**虚边**。

LCT 就是一种维护实链剖分方案，并支持实时改变剖分方案的数据结构。

利用一个 Splay 维护每一条实链，左侧在原树中靠上，右侧在原树中靠下。这样的一棵 Splay 称作一棵**辅树**。

然后每一个Splay 的根节点记录一个 `fa`，表示这一条树链挂在哪里（可以看做维护了一条虚边）。即，假如 `me` 是当前辅树的树根，且`me.fa = X`，这就意味着 `me` 节点所在的根链的顶部虚边所连接的节点是 `X` .

> 所以LCT维护的虚边中，父亲一定是对的，但孩子不一定是对的。

并且虚边**认父不认子**，也就是说刚刚的例子中，我们不需要在 `X` 节点处保存有关于他有一个虚儿子 `me` 的信息。只需要保证 `me` 可以找到父亲即可。

### `Access` 的实现

`Access` 是LCT中最核心的函数，其作用为【让 $u$ 这个点所在的树链成为一条到根的树链】。

我们先把 $u$ 旋转到辅树根，然后


## 维护动态图连通性

# Part 1 Euler Tour Tree

## 模板

欧拉放假树。

首先把每条无向边拆成两条有向边。然后把一个欧拉放在根节点。

欧拉从根节点开始DFS遍历这棵树，一旦经过一条有向边，就把它压进队尾。最后把所有东西依次弹出，就得到了欧拉序。

显然这其实就是一个欧拉回路。

> 欧拉序的长度为 $2n-2$ .

ETT就是用平衡树（一般是无旋treap）维护这个序列的数据结构。

### `makeroot` 的实现

# Part 2 Top Tree

抽象树。

要学的话似乎要爬论文（惊恐

而且考的频率也是非常低

那就先咕了。


